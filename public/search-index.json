[{"title":"Building The Right Cypress Commands","content":"# Building the right Cypress Commands\n\n[Cypress commands](https://docs.cypress.io/api/cypress-api/custom-commands) allow you to create custom functionality and even overwrite existing commands. Having this flexibility is incredibly convenient and powerful, but developers often struggle with when to write custom commands. A helpful thing to think about when you should write your custom command is _when your test code forces you to do so_. What exactly does this mean?\n\nWhen you begin to notice yourself writing the same functionality over and over again, aka repeating yourself, across multiple tests, that is usually a good sign to make a custom command. Don't begin writing your tests by thinking in abstractions, i.e., custom commands—rather **abstract custom commands from your tests**.\n\nYou already do this all the time as a JavaScript developer each time you create a custom function in your code. Typically you will create a custom JS function to abstract some functionality to re-use within your application, i.e., utility functions. Cypress commands are the same thing. They allow you to re-use functionality across multiple tests.\n\n## Creating a Custom Command\n\nLet's take a look an example.\n\n```js\ncy.get('[data-test=\"signup-first-name\"]').type(\"Bob\")\ncy.get('[data-test=\"signup-last-name\"]').type(\"Ross\")\ncy.get('[data-test=\"signup-username\"]').type(\"PainterJoy90\")\ncy.get('[data-test=\"signup-password\"]').type(\"s3cret\")\ncy.get('[data-test=\"signup-confirmPassword\"]').type(\"s3cret\")\n```\n\nIn this example, we are selecting several elements that all have a **data-test** attribute. While there is nothing inherently wrong with this syntax, it is quite a bit verbose. We could clean this up quite a bit and simplify things by creating our own custom command.\n\nInstead of writing all of the above, it would be nice to write.\n\n```js\ncy.getBySel(\"signup-first-name\").type(\"Bob\")\ncy.getBySel(\"signup-last-name\").type(\"Ross\")\ncy.getBySel(\"signup-username\").type(\"PainterJoy90\")\ncy.getBySel(\"signup-password\").type(\"s3cret\")\ncy.getBySel(\"signup-confirmPassword\").type(\"s3cret\")\n```\n\nLet's see how to create the custom command `cy.getBySel()`. You can create your own custom commands by placing them inside of **cypress/support/commands.js**.\n\nHere is what the `cy.getBysel()` looks like:\n\n```js\nCypress.Commands.add(\"getBySel\", (selector, ...args) => {\n  return cy.get(`[data-test=${selector}]`, ...args)\n})\n```\n\nAs you can see, our custom command is a simple wrapper around <apiLink apiName=\"get\" displayName=\"cy.get()\" />. This way, we can pass in the string contained within the **data-test** attribute, and our custom command will return the element.\n\n## Another Custom Command Example\n\nLet's take a look at another example. Let's say you need to log in as a user before each test. You can create a custom command that handles all of the logging in and authentication logic, so you can simply call it within your test.\n\n```js\nCypress.Commands.add(\"loginByApi\", (username, password) => {\n  return cy.request(\"POST\", `http://localhost:3000/login`, {\n    username,\n    password,\n  })\n})\n```\n\nIn this example, we use a custom command called `cy.loginByApi()`, which accepts a username and password and then sends a post request to our API login route. Now within our tests, we can call this command, passing in a username and password.\n\n```js\ndescribe(\"POST /login\", function () {\n  it(\"login as user\", function () {\n    cy.loginByApi(\"jdoe\", \"password123\").then((response) => {\n      expect(response.status).to.eq(200)\n    })\n  })\n})\n```\n\n## Practice\n\nIf you would like to practice how to build custom Cypress Commands, we have created a special repo which can be found [here](https://github.com/cypress-io/cypress-realworld-testing-blog). The installation instructions are located in the **README.md** file.\n\nThe practice file you are looking for can be found in **cypress/integration/Practice/cypress-commands.spec.js**.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/Answers/cypress-commands.spec.js**\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Building The Right Cypress Commands"},"url":"/advanced-cypress-concepts/building-the-right-cypress-commands","type":"lvl1"},{"title":"Database Initialization And Seeding","content":"# Database Initialization & Seeding\n\nMany people struggle with how to manage data necessary for testing. One reason why they struggle is that working with data for testing is often overlooked or forgotten about. In this lesson, we will discuss some strategies on how to work with data in your tests.\n\n## You need a strategy for your data\n\nIn the same way that you need to have a testing strategy to determine what to test, you also need a data strategy on how you will work with the data you need for your tests. Here are some things to be thinking about to help you come up with your data strategy.\n\n- Do you have a backend with your test users?\n- Do you need to create test users on the fly?\n- What are the relationships between the various entities in your system/application?\n  - For example, in the Real World App, users need to have a bank account to send and receive payments.\n- Are the database seeds and initialization owned by another team (backend)\n  - The entities in the system and their relationships are complicated; thus, the backend team has scripts and manages the test data\n  - The frontend team is instructed to issue API requests to re-seed the database, create users, delete users, form relationships between users\n- What data needs to come from the database, and which data can be mocked?\n- Do you need to anonymize the data before testing for PII or other personal data safety?\n- Does the test data change between environments like dev, staging, and prod?\n\n## Ways to create data for your tests\n\nThere are many ways to seed your database. Below are a few ways we recommend, ordered by our least favorite to our best option.\n\n## Using the UI to create the data you need (during your tests)\n\nThis method involves using Cypress to drive the UI to generate the data you need. For example, you could write tests that would allow Cypress to create users via your application UI by filling out a signup form with a generic user specifically for testing purposes.\n\n**Pros**\n\n- The easiest and most straightforward way\n- Confirms that your UI and backend are working correctly\n\n**Cons**\n\n- Take's a long time\n- Your spec files could potentially rely upon each other, which is an anti-pattern\n- Data initialization is less resilient because you don't have a way of knowing if the data exists\n- If your tests fail, your data will not be created, and any subsequent tests that rely upon the creation of this data will also fail.\n\n## Make queries to the database to create the data you need\n\nThis method involves writing raw queries, like SQL, to populate your database with the data you need for testing.\n\n**Pros**\n\n- Relies on the backend to manage the data\n- More reliable way to get your data\n- Faster than using the UI to initialize the data, i.e., the method listed above\n- Re-use backend logic, i.e., using an ORM or methods to obtain data from the backend for testing purposes. This is only possible if your front end and backend are in the same repo.\n\n**Cons**\n\n- Requires network interaction to get the data, possible issues with latency\n- Requires maintenance when your data model changes\n- Potential security issues with PII may need to anonymize data\n\n## Making API calls to your backend to provision data\n\nThis method involves utilizing special APIs set up to generate the data you need for your tests.\n\n**Pros**\n\n- Call and endpoint with parameters, and the backend creates the entities and returns them\n- Can ensure relationships between entities are established\n- Responsibility of test data is on the backend, not frontend or QA\n- Little to no maintenance on frontend/testing side; completely managed by backend\n\n**Cons**\n\n- Could potentially expose PII\n- May potentially need extra security measures if these endpoints are public-facing\n\n## Database dump or import\n\nThis method involves using a SQL dump or an export from one of your databases and then importing the export into another database explicitly used for testing.\n\n**Pros**\n\n- Working with actual data (potentially sanitized)\n- Efficient in that data used to drive tests would be provisioned outside of testing\n- Bulk insert of records\n- Possible for SQL and NoSQL backends, \"easier\" for SQL\n\n**Cons**\n\n- Depending on entities and where data is stored among regions and databases, i.e., cloud infrastructure, it can become quite complicated.\n- May require DevOps team for setup and deployment.\n\n## Custom scripts (factories) to generate \"test\" data\n\n**Pros**\n\n- Ultimate control over test data for entities and relationships\n\n**Cons**\n\n- All responsibility for test data is on the frontend/testing team\n- Script maintenance when data model or backend changes\n\n## Creating database seeds with factory scripts\n\nThere are many different libraries available to generate dummy test data. [Faker.js](https://www.npmjs.com/package/faker) is a popular library for Node.\n\nHere is an example script for generating fake users with [Faker](https://www.npmjs.com/package/faker).\n\n```js\n// generateSeedUsers.js\n\nimport path from \"path\"\nimport fs from \"fs\"\nimport shortid from \"shortid\"\nimport faker from \"faker\"\nimport bcrypt from \"bcryptjs\"\nimport { times } from \"lodash\"\n\nconst passwordHash = bcrypt.hashSync(\"s3cret\", 10)\n\nconst createFakeUser = () => ({\n  id: shortid(),\n  firstName: faker.name.firstName(),\n  lastName: faker.name.lastName(),\n  username: faker.internet.userName(),\n  password: passwordHash,\n  email: faker.internet.email(),\n  createdAt: faker.date.past(),\n  modifiedAt: faker.date.recent(),\n})\n\nexport const createSeedUsers = (numberOfUsers) =>\n  times(numberOfUsers, () => createFakeUser())\n\nexport const saveUsersSeed = (numberOfUsers) => {\n  const seedUsers = createSeedUsers(numberOfUsers)\n  // write seed users to seedUsers.json\n  fs.writeFile(path.join(process.cwd(), \"seedUsers.json\"), seedUsers)\n}\n```\n\nIn this example, we have a simple script that creates fake users and then writes those users to a **.json** file. You could then use this **.json** file as a fixture to drive some of your tests, or you could use this script to write the users to your test database, etc.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Database Initialization And Seeding"},"url":"/advanced-cypress-concepts/database-initialization-and-seeding","type":"lvl1"},{"title":"How To Test Various Browsers And Viewports","content":"# How to Test Various Browsers & Viewports\n\n## Different Browsers\n\nRunning all of your tests within [multiple browsers](https://docs.cypress.io/guides/guides/cross-browser-testing) and across various screen sizes is incredibly important. Currently, Cypress supports [Chrome-family browsers](https://docs.cypress.io/guides/guides/launching-browsers#Chrome-Browsers) (including Electron and Chromium-based Microsoft Edge) and Firefox.\n\nYou can also configure Cypress to run your tests within a specific window size with custom configurations. A great example of how to do this is in the [Real World App (RWA)](https://github.com/cypress-io/cypress-realworld-app). If you look at the [GitHub Actions workflow](https://github.com/cypress-io/cypress-realworld-app/blob/develop/.github/workflows/main.yml), we will run the tests within the RWA in Chrome Desktop, Chrome Mobile, Firefox Desktop, and Firefox Mobile.\n\nWe can tell Cypress to use a specific browser by specifying the browser we want with the browser key like so:\n\n```yaml\nbrowser: Firefox\n```\n\nThis works excellent in CI, but what if you want to do this locally?\n\nYou can pass in which browser you would like Cypress to run in via the command line like so:\n\n```bash\ncypress run --browser Firefox\n```\n\nYou can also select which browser to run via the UI by selecting it in the dropdown like so:\n\n![](/images/advanced-cypress-concepts/how-to-test-various-browsers-and-viewports/Screen_Shot_2021-08-31_at_9.16.07_AM.png)\n\nYou can even do this on a test by test basis by passing an [options object to your tests](https://docs.cypress.io/guides/guides/cross-browser-testing#Running-Specific-Tests-by-Browser).\n\n```js\n// Run the test if Cypress is running\n// using the built-in Electron browser\nit('has access to clipboard', { browser: 'electron' }, () => {\n  ...\n})\n\n// Run the test if Cypress is run via Firefox\nit('Download extension in Firefox', { browser: 'firefox' }, () => {\n  // ...\n})\n\n// Run the test if Cypress is run via Chrome\nit('Show warning outside Chrome', { browser: 'chrome' }, () => {\n  // ...\n})\n```\n\nYou can even do this for all tests located within a `describe()` block like so:\n\n```js\ndescribe(\"happy path suite\", { browser: \"firefox\" }, () => {\n  it(\"...\")\n  it(\"...\")\n  it(\"...\")\n})\n```\n\nIn this example, Firefox will run all tests located within this `describe()`.\n\n## Testing Mobile\n\nAll of the tests within the RWA are written for Desktop by default. Within the `package.json`, we have custom scripts to launch Cypress with mobile dimensions.\n\n```json\n\"cypress:open:mobile\": \"cypress open --config viewportWidth=375,viewportHeight=667\",\n\"cypress:run:mobile\": \"cypress run --config viewportWidth=375,viewportHeight=667\",\n```\n\nAs you can see, when these commands are executed, we are passing along some custom configuration that tells Cypress the **viewportWidth** and **viewportHeight** to use when launching our tests.\n\nWe also have a utility function called `isMobile()` which determines if our tests are being run at the mobile viewport. Here is what that function looks like:\n\n```js\nexport const isMobile = () => {\n  return (\n    Cypress.config(\"viewportWidth\") <\n    Cypress.env(\"mobileViewportWidthBreakpoint\")\n  )\n}\n```\n\nThe environment variable `mobileViewportWidthBreakpoint` is located within the `cypress.json` config file.\n\n```json\n{\n  // ...\n\n  \"env\": {\n    \"apiUrl\": \"http://localhost:3001\",\n    \"mobileViewportWidthBreakpoint\": 414,\n    \"coverage\": false,\n    \"codeCoverage\": {\n      \"url\": \"http://localhost:3001/__coverage__\"\n    }\n  },\n  \"experimentalStudio\": true\n}\n```\n\nIn our tests, we can use this function to determine if the tests are being executed within our mobile viewport and react accordingly using a conditional.\n\n```js\nit(\"should remember a user for 30 days after login\", function () {\n  cy.database(\"find\", \"users\").then((user: User) => {\n    cy.login(user.username, \"s3cret\", { rememberUser: true })\n  })\n\n  // Verify Session Cookie\n  cy.getCookie(\"connect.sid\").should(\"have.property\", \"expiry\")\n\n  // Logout User\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click()\n  }\n  cy.getBySel(\"sidenav-signout\").click()\n  cy.location(\"pathname\").should(\"eq\", \"/signin\")\n  cy.visualSnapshot(\"Redirect to SignIn\")\n})\n```\n\nIn the case of the RWA, the sidebar is hidden by default on mobile. This function will fire whenever our viewport width is less than **414px**.\n\nThis allows the same test to be used in both Desktop and Mobile orientations instead of coding mobile-specific tests.\n\nFor more info, check out these articles within our docs.\n\n[Test Configuration](https://docs.cypress.io/guides/references/configuration#Test-Configuration)\n\n[Cross Browser Testing](https://docs.cypress.io/guides/guides/cross-browser-testing)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"How To Test Various Browsers And Viewports"},"url":"/advanced-cypress-concepts/how-to-test-various-browsers-and-viewports","type":"lvl1"},{"title":"Important Cypress Methods You Need To Know","content":"# Important Cypress Methods You Need to Know\n\nCypress has a lot of [methods & commands](https://docs.cypress.io/api/table-of-contents). While our documentation covers them in great detail, it can be overwhelming trying to learn them all. This lesson will highlight some of the most important methods that we think you should know. These are not methods you will use all of the time, but simply knowing they exist will be incredibly helpful as you begin to write more complicated tests.\n\n## .its()\n\nGet a property's value on the previously yielded subject.\n\n`.its()` is a handy method when you want to get the property off of something. For example if you want to make an assertion against an array.\n\n```js\ncy.wrap([\"Wai Yan\", \"Yu\"]).its(1).should(\"eq\", \"Yu\") // true\n```\n\nOr maybe you want to get the property from an object and make an assertion.\n\n```js\ncy.wrap({ age: 52 }).its(\"age\").should(\"eq\", 52) // true\n```\n\nIn the example in the Invoke section above, we are using <apiLink apiName=\"its\" displayName=\".its()\" /> to grab the `results` from the `@publicTransactions` alias, which is an intercepted network request.\n\n```js\nit(\"first five items belong to contacts in public feed\", function () {\n  // ...\n\n  cy.wait(\"@publicTransactions\")\n  .its(\"response.body.results\")\n  .invoke(\"slice\", 0, 5)\n```\n\nBy using <apiLink apiName=\"its\" displayName=\".its()\" /> we can get access to the `results` array which allows us to call `.invoke()` to perform `.slice()` on it.\n\n`.its()` is a very handy method and will become a useful tool in your \"Cypress tool belt.\" You can find out more about it in our [API docs page](https://docs.cypress.io/api/commands/its).\n\n## .invoke()\n\nInvoke a function on the previously yielded subject.\n\n[Cypress is just JavaScript](/cypress-fundamentals/cypress-is-just-javascript), and the <apiLink apiName=\"invoke\" displayName=\"cy.invoke()\" /> method allows you to call JS functions on JS data types.\n\nIn the example below, we are invoking the `Array.slice()` function on the response data returned from an aliased intercept.\n\n```js\nbeforeEach(() => {\n  cy.intercept(\"GET\", \"/users\").as(\"users\")\n})\n\nit(\"slices the users returned from /users endpoint\", () => {\n  cy.wait(\"@users\").its(\"response.body.results\").invoke(\"slice\", 0, 5)\n  // ...\n})\n```\n\nCheck out our [API docs page](https://docs.cypress.io/api/commands/invoke) for more info on <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" />\n\n## .request()\n\nMake an HTTP request.\n\n`.request()` is a helpful method anytime you need to make an HTTP request within your tests and perform expectations against it.\n\n```js\ncy.request(\"POST\", \"http://localhost:8888/users/admin\", { name: \"Jane\" }).then(\n  (response) => {\n    // response.body is automatically serialized into JSON\n    expect(response.body).to.have.property(\"name\", \"Jane\") // true\n  }\n)\n```\n\nWe make extensive use of <apiLink apiName=\"request\" displayName=\"cy.request()\" /> in our [API tests](https://github.com/cypress-io/cypress-realworld-app/tree/develop/cypress/tests/api) within the [Real World App (RWA)](https://github.com/cypress-io/cypress-realworld-app).\n\n## .within()\n\nScopes all subsequent Cypress commands to within an element. Useful when working within a particular group of elements such as a `<form>`.\n\nWhen you are working with elements, you need to drill down into its children, grandchildren, etc. You can use <apiLink apiName=\"within\" displayName=\".within()\" /> to limit the scope of Cypress commands to within a specific element. For example.\n\n```js\nit(\"ensures the section lesson exists\", () => {\n  cy.getBySel(\"section-steps\").within(() => {\n    cy.getBySel(\"lesson-complete-0\").should(\"exist\")\n  })\n})\n```\n\nYou can find out more about `.within()` on our [API docs page](https://docs.cypress.io/api/commands/within).\n\n## Practice\n\nIf you would like to practice using some of these Cypress methods, we have created a special repo which can be found [here](https://github.com/cypress-io/cypress-realworld-testing-blog). The installation instructions are located in the **README.md** file.\n\nThe practice file you are looking for can be found in **cypress/integration/Practice/cypress-methods.spec.js**.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/Answers/cypress-methods.spec.js**\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Important Cypress Methods You Need To Know"},"url":"/advanced-cypress-concepts/important-cypress-methods-you-need-to-know","type":"lvl1"},{"title":"Integration And Api Tests","content":"# Integration & API Tests\n\nCypress provides a great developer experience for testing APIs. We used Cypress extensively to test the various APIs within the [Real World App (RWA)](https://github.com/cypress-io/cypress-realworld-app). Before we built the UI, we wrote various [API and integration tests](https://github.com/cypress-io/cypress-realworld-app/tree/develop/cypress/tests/api) with Cypress to ensure the application APIs were working as expected.\n\n## Example API Test\n\nLet's look at one of the API tests from the RWA to understand better how to test APIs using Cypress.\n\n```js\n// cypress/tests/api/api-users.spec.ts\n\ncontext(\"GET /users\", function () {\n  it(\"gets a list of users\", function () {\n    cy.request(\"GET\", \"/users\").then((response) => {\n      expect(response.status).to.eq(200)\n      expect(response.body.results).length.to.be.greaterThan(1)\n    })\n  })\n})\n```\n\nIn this simple test, we make a **GET** request to our **/users** route using <apiLink apiName=\"request\" displayName=\"cy.request()\" />. We assert that the response returns a **200** status code and that more than one user is returned from the response.\n\n## Developer Experience\n\nOne of the pleasant aspects of using Cypress for testing APIs is that you can easily see and interact with the response data from within the Test Runner UI.\n\nClicking upon the request step in the Cypress Command Log, we can see all of the response data in the browser's console.\n\n![](/images/advanced-cypress-concepts/integration-and-api-tests/Screen_Shot_2021-09-01_at_9.20.04_AM.png)\n\nThis allows you to quickly inspect and debug the data coming back from your APIs against the actual data returned in the original requests.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Integration And Api Tests"},"url":"/advanced-cypress-concepts/integration-and-api-tests","type":"lvl1"},{"title":"Intercepting Network Requests","content":"# Intercepting Network Requests\n\nKnowing how to test network requests and responses is important for every web application. In this lesson you will learn how to use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to manipulate and test network requests and responses.\n\n## Mocking, Spying & Stubbing\n\nIf you are unfamiliar with the terminology of Mocking, Spying or Stubbing you can learn more about each in our docs.\n\n### Mocking with Fixtures\n\n- [Fixtures](https://docs.cypress.io/guides/guides/network-requests#Fixtures)\n- [Fixture API Docs](https://docs.cypress.io/api/commands/fixture)\n\n### Spying\n\n- [Spies](https://docs.cypress.io/guides/guides/stubs-spies-and-clocks#Spies)\n- [Spy API Docs](https://docs.cypress.io/api/commands/spy)\n\n### Stubbing\n\n- [Stubs](https://docs.cypress.io/guides/guides/stubs-spies-and-clocks#Stubs)\n- [Stub API Docs](https://docs.cypress.io/api/commands/stub)\n\n## Example Use Cases\n\n### Intercepting Server Requests\n\nThe most basic way to intercept a server request is as follows:\n\n```js\ncy.intercept(\"POST\", \"/users\")\n```\n\nIn this example we are intercepting any **POST** request to the **/users** route. Typically you will also **alias** an intercept to perform additional actions, like waiting, later in your test(s).\n\nWe explain how waiting works in the [Waiting & Retry-ability](/cypress-fundamentals/waiting-and-retry-ability) lesson.\n\n```js\ncy.intercept(\"POST\", \"/users\").as(\"signup\")\n\n// ...\n\ncy.wait(\"@signup\")\n```\n\n### Overriding an existing intercept\n\nSometimes you may need to override and already existing intercept by using a **fixture** to **mock** the response data. Let's look at an example from the [Real World App](https://github.com/cypress-io/cypress-realworld-app/blob/develop/cypress/tests/ui/transaction-feeds.spec.ts).\n\n```js\nbeforeEach(function () {\n  // ...\n\n  cy.intercept(\"GET\", \"/transactions/public*\").as(\"publicTransactions\")\n\n  // ...\n})\n```\n\nIn this example, we intercept any **GET** request to any route that matches **/transactions/public\\***. We are doing this in a `beforeEach()`, which means this intercept will run before every test.\n\nLater on, In one of our tests, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept and override this same **GET** and route but using a **fixture** to mock the response.\n\n```js\ncy.intercept(\"GET\", \"/transactions/public*\", {\n  // ...\n  fixture: \"public-transactions.json\",\n}).as(\"mockedPublicTransactions\")\n```\n\nSo as you can see, we can also intercept other intercepts and then provide mocked data using a **fixture**. We alias this intercept override as **mockedPublicTransactions**.\n\n### Changing Headers\n\nYou can also use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to modify headers from a response.\n\n```js\ncy.intercept(\"GET\", \"/transactions/public*\", {\n  headers: {\n    \"X-Powered-By\": \"Express\",\n    Date: new Date().toString(),\n  },\n})\n```\n\nIn this example we are dynamically modifying the Date header and also adding a new header `\"X-Powered-By\": \"Express\"`.\n\nThe original headers from the response will remain intact. These new headers are appended to the original ones.\n\n### Modifying Response Data\n\nSometimes you will need to modify a portion of the response data while leaving everything else intact.\n\n```js\ncy.intercept(\"POST\", \"/bankaccounts\", (req) => {\n  const { body } = req\n  req.continue((res) => {\n    res.body.data.listBankAccount = []\n  })\n})\n```\n\nIn this example, we are overriding the `listBankAccount` property and setting it to be an empty array. We need to use `.continue()` to modify the response data. You can learn more about how to use `.continue()` [here](https://docs.cypress.io/api/commands/intercept#Controlling-the-outbound-request-with-req-continue).\n\n### Inspecting a Request\n\nYou can also use intercept to inspect a request, in the callback passed to <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" />.\n\n```js\ncy.intercept(\"POST\", apiGraphQL, (req) => {\n  const { body } = req\n\n  if (\n    body.hasOwnProperty(\"operationName\") &&\n    body.operationName === \"CreateBankAccount\"\n  ) {\n    req.alias = \"gqlCreateBankAccountMutation\"\n  }\n})\n```\n\nIn this example, we are using intercept to inspect a GraphQL query to determine what kind of query it is. If the query is `CreateBankAccount` then we are setting its alias to `gqlCreateBankAccountMutation`\n\nTo learn more check out these resources in our docs:\n\n- [Network Requests](https://docs.cypress.io/guides/guides/network-requests)\n- [Intercept API docs](https://docs.cypress.io/api/commands/intercept)\n- [Stubs, Spies & Clocks](https://docs.cypress.io/guides/guides/stubs-spies-and-clocks)\n\n## Practice\n\nIf you would like to practice intercepting Network Requests and working with the Network in general with Cypress, we have created a special repo which can be found [here](https://github.com/cypress-io/cypress-realworld-testing-blog). The installation instructions are located in the **README.md** file.\n\nThe practice file you are looking for can be found in **cypress/integration/Practice/network-requests.spec.js**.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/Answers/network-requests.spec.js**\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Intercepting Network Requests"},"url":"/advanced-cypress-concepts/intercepting-network-requests","type":"lvl1"},{"title":"Running Cypress In Ci","content":"# Running Cypress in CI\n\nOne of Cypress's most essential and powerful use cases is having it run in your CI/CD pipeline. This way, every time you make a change to your codebase, your CI Pipeline will automatically run all of your Cypress tests to ensure that nothing has broken in your application. We have extensive documentation on using Cypress in CI and how to integrate it with various CI providers.\n\n### What is Continuous Integration(CI)\n\n<iframe\n  width=\"560\"\n  height=\"315\"\n  src=\"https://www.youtube.com/embed/USX6AntcPyg\"\n  title=\"YouTube video player\"\n  frameborder=\"0\"\n  allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n  allowfullscreen\n></iframe>\n\n### Introduction to Continuous Integration\n\nWe have an extensive guide covering everything you need to know about using Cypress in CI. You can find that guide [here](https://docs.cypress.io/guides/continuous-integration/introduction).\n\n### Integrating Cypress with various CI Providers\n\nIn our docs, we have several [examples](https://docs.cypress.io/guides/continuous-integration/ci-provider-examples) and guides on integrating Cypress with some of the most popular CI providers.\n\n- [Circle CI](https://docs.cypress.io/guides/continuous-integration/circleci)\n- [GitHub Actions](https://docs.cypress.io/guides/continuous-integration/github-actions)\n- [GitLab CI](https://docs.cypress.io/guides/continuous-integration/gitlab-ci)\n- [Bitbucket Pipelines](https://docs.cypress.io/guides/continuous-integration/bitbucket-pipelines)\n- [AWS CodeBuild](https://docs.cypress.io/guides/continuous-integration/aws-codebuild)\n\n### Cypress Dashboard\n\nThe [Cypress Dashboard](https://www.cypress.io/dashboard/) increases test velocity while giving total visibility into tests running in your CI pipeline. It also provides automatic parallelization and load balancing, so your tests run incredibly fast.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Running Cypress In Ci"},"url":"/advanced-cypress-concepts/running-cypress-in-ci","type":"lvl1"},{"title":"Using Data To Build Dynamic Tests","content":"# Using Data to Build Dynamic Tests\n\nIn the lesson [Database Initialization & Seeding](/advanced-cypress-concepts/database-initialization-and-seeding), we give you several strategies for creating the data necessary for your tests. In this lesson, we will help you better understand how to use that data to drive your tests.\n\n## What are Data-Driven Tests?\n\nWhen we speak of \"Data-Driven Tests,\" we refer to using variables, fixtures, or data from a database to construct all aspects of a test (UI interactions, expectations, and the test itself).\n\nFor example, let's say you have a test which tests the login form in your app. You could hard code the data, like so:\n\n```js\ncy.get(\"username\").type(\"jdoe\")\ncy.get(\"password\").type(\"password123\")\n```\n\nOr you could use data from variables.\n\n```js\nconst users = [\n  {\n    username: \"John\",\n    password: \"password123\",\n  },\n  {\n    username: \"Jane\",\n    password: \"password123\",\n  },\n]\n\ncy.get(\"username\").type(users[0].username)\ncy.get(\"password\").type(users[0].password)\n```\n\nYou could also use data from a [fixture](https://docs.cypress.io/api/commands/fixture).\n\n```js\ncy.fixture(\"users.json\").as(\"usersData\")\n\ncy.get(\"username\").type(usersData[0].username)\ncy.get(\"password\").type(usersData[0].password)\n```\n\nOr, you could use an actual user from your database.\n\n## Using data from remote systems (API, database, etc.) to drive seed data and tests\n\n```js\ndescribe(\"Notifications\", function () {\n  const ctx = {}\n\n  beforeEach(function () {\n    // ...\n\n    cy.database(\"filter\", \"users\").then((users) => {\n      ctx.userA = users[0]\n      ctx.userB = users[1]\n      ctx.userC = users[2]\n    })\n  })\n\n  it(\"allows users to login\", () => {\n    cy.get(\"username\").type(ctx.userA.userName)\n    cy.get(\"password\").type(ctx.userA.password)\n  })\n})\n```\n\nIn this example, `cy.database()` is a custom Cypress command which performs operations on our database depending upon which arguments are passed into it. You can learn how this command works [here](/real-world-examples/custom-cypress-commands#cydatabase).\n\n## Benefits of Data-Driven Tests\n\nUsing actual data has several benefits. First, you are using existing data from your application. This more closely mimics how real users interact with your app. Hard-coded data can be challenging to maintain over time, as it requires consistent updating and maintenance. Instead of hard-coded data, the only thing you have to maintain is the data itself.\n\n## Wrap Up\n\nCongrats! You have finished the fourth course of Real World Testing with Cypress. If you have completed all four courses, make sure to check out the [Real World Examples](/real-world-examples) as they demonstrate real-world usage of Cypress testing methods, patterns, and workflows.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Using Data To Build Dynamic Tests"},"url":"/advanced-cypress-concepts/using-data-to-build-dynamic-tests","type":"lvl1"},{"title":"Command Chaining","content":"# Command Chaining\n\nIt's important to understand the mechanism Cypress uses to chain commands together. It manages a Promise chain on your behalf, with each command yielding a 'subject' to the following command until the chain ends or there is an error. The developer should not need to use Promises directly, but understanding how they work is helpful.\n\nFor example, a chain of Cypress commands looks like this:\n\n```js\ncy.get(\".todo-list li\").find(\"label\").should(\"contain\", \"Buy Milk\")\n```\n\nIn this example, <apiLink apiName=\"get\" displayName=\"cy.get()\" /> will yield the `<li>` subject to <apiLink apiName=\"find\" displayName=\".find()\" /> which will then search for the `<label>` element. Finally, we make an assertion that the `<label>` contains the text \"Buy Milk.\"\n\nHowever, it is important to note that not all Cypress commands yield a subject that can be chained. For instance, <apiLink apiName=\"clearcookies\" displayName=\"cy.clearCookies()\" /> yields `null`, which _cannot_ be chained.\n\nCypress commands like <apiLink apiName=\"get\" displayName=\"cy.get()\" /> and <apiLink apiName=\"contains\" displayName=\"cy.contains()\" /> yield DOM elements that can be chained, like in the example above.\n\nWhen you want to act upon a subject directly from a Cypress command, you need to yield the subject to <apiLink apiName=\"then\" displayName=\".then()\" />. We cover <apiLink apiName=\"then\" displayName=\".then()\" /> and <apiLink apiName=\"wrap\" displayName=\"cy.wrap()\" /> in the [Understanding the Asynchronous nature of Cypress](/cypress-fundamentals/understanding-the-asynchronous-nature-of-cypress) lesson.\n\nYou can learn more about command chaining from our docs [here](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress#Chains-of-Commands).\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Command Chaining"},"url":"/cypress-fundamentals/command-chaining","type":"lvl1"},{"title":"Cypress Is Just Javascript","content":"# Cypress is Just JavaScript\n\n## Generating Tests Dynamically with Lodash\n\nIt is important to recognize that Cypress is just JavaScript. For example, here is a test where we are using `_.each` from [Lodash](https://lodash.com/) to dynamically create tests.\n\nBy the way, did you know that Cypress natively imports [Lodash](https://lodash.com/)? You can use [Lodash](https://lodash.com/) in your tests by importing it, as you see in the example below.\n\n```js\nconst { _ } = Cypress // importing lodash\n\n_.each(feedViews, (feed, feedName) => {\n      it(`paginates ${feedName} transaction feed`, function () {\n        cy.getBySelLike(feed.tab)\n          .click()\n          .should(\"have.class\", \"Mui-selected\")\n          .contains(feed.tabLabel, { matchCase: false })\n          .should(\"have.css\", { \"text-transform\": \"uppercase\" });\n        cy.getBySel(\"list-skeleton\").should(\"not.exist\");\n        cy.visualSnapshot(`Paginate ${feedName}`);\n\n        cy.wait(`@${feed.routeAlias}`)\n          .its(\"response.body.results\")\n          .should(\"have.length\", Cypress.env(\"paginationPageSize\"));\n// ...\n```\n\nThis example comes from the [Real World App](https://github.com/cypress-io/cypress-realworld-app).\n\n## Using Array.forEach()\n\nHere is another example where we use [Array.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) to iterate over an array.\n\n```js\nconst people = [\"moe\", \"curly\", \"larry\"]\n// Use method from lodash to get a person to use in a comment\nconst transactions = [{ id: 1 }]\n_.each(transaction,\nit(\"comments on a transaction\", function () {\n    cy.getBySelLike(\"transaction-item\").first().click();\n    cy.wait(\"@getTransaction\");\n\n    const comments = [\"Thank you!\", \"Appreciate it.\"];\n\n    comments.forEach((comment, index) => {\n      cy.getBySelLike(\"comment-input\").type(`${comment}{enter}`);\n      cy.getBySelLike(\"comments-list\").children().eq(index).contains(comment);\n    });\n\n    cy.getBySelLike(\"comments-list\").children().should(\"have.length\", comments.length);\n    cy.visualSnapshot(\"Comment on Transaction\");\n  });\n```\n\n## Practice\n\nIf you would like to practice how to to use JavaScript in Cypress, we have created a special repo which can be found [here](https://github.com/cypress-io/cypress-realworld-testing-blog). The installation instructions are located in the **README.md** file.\n\nThe practice file you are looking for can be found in **cypress/integration/Practice/just-javascript.spec.js**.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/Answers/just-javascript.spec.js**\n\n## Wrap Up\n\nCongrats! You have finished the third course of Real World Testing with Cypress. In the next course you will learn some of the more advanced concepts in Cypress that take your tests to the next level.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Cypress Is Just Javascript"},"url":"/cypress-fundamentals/cypress-is-just-javascript","type":"lvl1"},{"title":"Cypress Runs In The Browser","content":"# Cypress runs in the browser\n\nCypress's [architecture](https://docs.cypress.io/guides/overview/key-differences#Architecture), unlike most other testing tools, runs _inside_ of the browser. This means that your tests are being executed in the same environment as your application. This allows Cypress to detect all events that are fired by your browser and give it real native access to everything within your tests.\n\nMost other testing tools (like Selenium) run outside of the browser and execute remote commands across the network to control the browser. Cypress is the exact opposite!\n\nSince Cypress is running in the browser, it also operates at the network layer by reading and altering web traffic on the fly. Cypress can therefore modify everything coming in and out of the browser, which will allow you to test your application in ways no other testing tool can. This also gives it native access to things like the **window** object, **document**, DOM elements, service workers, etc.\n\nThis distinction can aid in many ways, including setting up or modifying frontend state libraries such as Redux or MobX directly from your Cypress tests.\n\nAnything the browser can access, Cypress can as well.\n\nThis is not without [trade-offs](https://docs.cypress.io/guides/references/trade-offs#Inside-the-browser), however.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Cypress Runs In The Browser"},"url":"/cypress-fundamentals/cypress-runs-in-the-browser","type":"lvl1"},{"title":"Cypress Ui Overview","content":"# Cypress UI Overview\n\nThis is what Cypres looks like when you launch it for the first time.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.10.45_AM.png)\n\nAt the top is a navigation bar that includes tabs for Tests, Runs, Settings, and Browser Selection.\n\nThe Tests tab is where all of your Cypress tests live and allows you to select which tests you would like Cypress to run.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.16.59_AM.png)\n\nThe Runs tab is where you can connect Cypress to the [Cypress Dashboard](https://www.cypress.io/dashboard/) to see your recorded test results.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.15.59_AM.png)\n\nThe Settings tab contains all the configuration settings for Cypress.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.16.02_AM.png)\n\nFinally, the browser selection drop-down lets you tell Cypress which browser you would like to launch and run your tests.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.16.07_AM.png)\n\n## Tests Tab\n\nWhen you first install Cypress, it will automatically create some sample integration tests for you. These tests are an excellent way to learn some of the basics and some more advanced concepts. We highly recommend you look through them.\n\nYou can easily collapse or expand your directories and tests by clicking on the \"Collapse All\" or \"Expand All\" buttons.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.20.10_AM_copy.png)\n\nYou can also tell Cypress to execute all of your tests by clicking the \"Run 20 integration tests.\"\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.20.10_AM.png)\n\n## Test Runner UI\n\nClicking on one of your test files will launch the [Cypress Test Runner UI](https://docs.cypress.io/guides/core-concepts/test-runner#Overview).\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.29.33_AM.png)\n\nOn the left-hand side, you will see the [Cypress Command Log](https://docs.cypress.io/guides/core-concepts/test-runner#Command-Log). This is where information about each test will be displayed. In the example above, all of our tests are passing, denoted by a green checkmark.\n\nYou can click on any of your tests to see detailed information about that specific test.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.37.49_AM.png)\n\nThis becomes incredibly useful when you have failing tests as the assertion error will be displayed along with the exact line of code that failed.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.38.56_AM.png)\n\nOn the right-hand side is your application.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.41.06_AM.png)\n\nRemember, since Cypress runs in the browser, you also have access to your browser's dev tools.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.41.46_AM.png)\n\n## Test Runner Toolbar\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM.png)\n\nAt the top of the Test Runner UI is a toolbar with several handy features.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM%201.png)\n\nThe first item is a button that will show the main Cypress window with all of your test files. This is a handy way to launch subsequent files and tests.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM%202.png)\n\nNext, the toolbar displays how many of your tests have passed, failed, and are pending.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM%203.png)\n\nThe toolbar also displays the total duration it took for all of your tests to run.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM%204.png)\n\nCypress will automatically scroll down as your tests are being executed to keep the most current action in view. You can disable this auto-scrolling feature by clicking this button.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM%205.png)\n\nYou can relaunch all of your tests with this button.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_9.42.57_AM%206.png)\n\nThe Cypress Test Runner also includes something called the [Selector Playground](https://docs.cypress.io/guides/core-concepts/test-runner#Selector-Playground). When clicked, it will open up a new toolbar under your application window.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_10.02.52_AM.png)\n\nThis behaves similarly to the element selector in your browser's dev tools. By highlighting an element in your application, Cypress will populate the `cy.get()` method and populate it with the correct selector to `.get()` that element.\n\nOnce you have selected the element you want, click the copy to clipboard button to paste it into your test file.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_10.05.32_AM.png)\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_10.07.16_AM.png)\n\nYou can also see the current URL of your application in the address bar.\n\n![](/images/cypress-fundamentals/cypress-ui-overview/Screen_Shot_2021-08-31_at_10.07.16_AM_copy.png)\n\nFinally, you can see the current browser window dimensions.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Cypress Ui Overview"},"url":"/cypress-fundamentals/cypress-ui-overview","type":"lvl1"},{"title":"How To Debug Failing Tests","content":"# How to Debug Failing Tests\n\nKnowing how to debug failing tests is arguably one of the most important and useful skills for you to learn. In this lesson we will discuss various tips, methods and techniques to help you debug and fix your failing tests.\n\n## Cypress UI\n\nThe Cypress UI is one of the fastest ways to figure out what went wrong with your tests.\n\n![](/images/cypress-fundamentals/how-to-debug-failing-tests/Screen_Shot_2021-08-31_at_2.42.05_PM.png)\n\nIt can also be incredibly useful to see all of the steps your tests took before the error was triggered. When you click on a step, Cypress will output useful information to the browser's console.\n\nFor example, in the failing test above, when clicking upon the assertion step, Cypress logs out the actual array in the console, which after inspection shows that there is only a single element within it.\n\n![](/images/cypress-fundamentals/how-to-debug-failing-tests/Screen_Shot_2021-08-31_at_2.43.25_PM.png)\n\n## Screenshots & Videos\n\nWhen you are running Cypress in headless mode by using the `cypress run` command, screenshots and videos will automatically be recorded anytime there is a failure. This is incredibly useful, especially when running your tests in CI, as it provides you with not only a screenshot at the exact point of failure, but also a video of your failing test.\n\nYou can tell Cypress to take a screenshot manually by using the <apiLink apiName=\"screenshot\" displayName=\"cy.screenshot()\" /> command.\n\n## Logging\n\nThere are two useful ways to log information from your tests. One way is to use <apiLink apiName=\"log\" displayName=\"cy.log()\" /> the other is to use `console.log()` . Remember [Cypress is just JavaScript](/cypress-fundamentals/cypress-is-just-javascript) so you can leverage all of the helpful debugging techniques you use in JS too.\n\n[cy.log()](https://docs.cypress.io/api/commands/log) will print a message to the Cypress Command Log\n\n![](/images/cypress-fundamentals/how-to-debug-failing-tests/Screen_Shot_2021-08-31_at_2.55.00_PM.png)\n\nYou can also use `console.log()` which will log to the browser's console.\n\n```js\nconsole.log(\"my custom message\")\n```\n\n![](/images/cypress-fundamentals/how-to-debug-failing-tests/Screen_Shot_2021-08-31_at_2.55.53_PM.png)\n\n## Browser Dev Tools\n\nSince Cypress runs in the browser, you have full access to all of the information from your browser's developer tools. This means you can use the same techniques and functionality you are used to using when debugging issues with your application code to debug your failing Cypress tests too.\n\n![](/images/cypress-fundamentals/how-to-debug-failing-tests/browser-dev-tools.gif)\n\n## Practice\n\nIf you would like to practice how to debug failing tests in Cypress, we have created a special repo which can be found [here](https://github.com/cypress-io/cypress-realworld-testing-blog). The installation instructions are located in the **README.md** file.\n\nThe practice file you are looking for can be found in **cypress/integration/Practice/debug-failing-tests.spec.js**.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/Answers/debug-failing-tests.spec.js**\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"How To Debug Failing Tests"},"url":"/cypress-fundamentals/how-to-debug-failing-tests","type":"lvl1"},{"title":"How To Write A Test","content":"# How to Write a Test\n\nWhen first learning how to write automated tests, it can be easy to get stuck not knowing how to write the test. Tests should be composed using a pattern that makes them easy to write, reason about, and expand. One pattern is the AAA (Arrange-Act-Assert) pattern, which encourages the organization of the test code in a way that allows the most readability and flexibility.\n\nIn step one, the **Arrange** step, you have to perform some setup for your test. For example, in the case of a Cypress end-to-end test, you need to tell Cypress to open the browser and navigate to the correct URL.\n\n```js\ncy.visit(\"http://localhost:8888\")\n```\n\nIn step two, the **Act** step, you perform some action. For example, in the case of a todo app, you want to test that you can add a single todo.\n\n```js\ncy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n```\n\nIn this example, we are getting the element with the class of **.new-todo** and then typing \"Buy Milk\" and simulating pressing the **Enter** key to add the todo.\n\nFinally, in step three, you **Assert**. In this step, you assert that the thing you acted upon in step two did what you expected.\n\n```js\ncy.get(\".todo-list li\").should(\"have.length\", 1)\n```\n\nIn this example, we are getting the element that contains the todo items that we added to the app and asserting that there is only a single todo.\n\nWith these three steps in mind, here is what a simple Cypress end-to-end test looks like for a TodoMVC application.\n\n## A simple end-to-end test\n\nThe following example is from the React TodoMVC app, which we cover in the \"Testing your first application\" section.\n\n```js\n// app.spec.js\n\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\") // Arrange\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\") // Act\n    cy.get(\".todo-list li\").should(\"have.length\", 1) // Assert\n  })\n})\n```\n\nBefore breaking this test file down, it is important to note that Cypress is built upon [Mocha](https://mochajs.org/). In this example, all of the functions other than those that begin with `cy` come from Mocha.\n\nEach test file will typically begin with a `describe()` function or \"block.\" This function provides a way to organize your tests and makes things easier to read. Test files can have multiple `describe()` within them as it provides the context for the tests written inside them.\n\nNext, we have an `it` block. This is our actual test and where our test code goes. We first provide a test name \"adds a single todo\" and then pass in a callback function. Within the body of our test, we are doing three things.\n\n### 1. Arrange\n\nTelling Cypress to visit the URL **http://localhost:8888**\n\n### 2. Act\n\nGetting the element with the class of **.new-todo** and typing in the string \"Buy Milk\" and pressing the **Enter** key.\n\n### 3. Assert\n\nWe are asserting that only a single todo has been added to the app.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"How To Write A Test"},"url":"/cypress-fundamentals/how-to-write-a-test","type":"lvl1"},{"title":"Understanding The Asynchronous Nature Of Cypress","content":"# Understanding the Asynchronous nature of Cypress\n\nThis is arguably one of the most crucial Cypress concepts that you need to understand. How Cypress handles things asynchronously is often misunderstood by developers and can lead to issues and confusion later on, especially when trying to debug your tests.\n\n## Return vs. Yield\n\nCypress commands **DO NOT** return their subjects. This means you **cannot** do things like this:\n\n```js\n// THIS WILL NOT WORK\nconst button = cy.get(\"button\")\n\nbutton.click()\n```\n\nThis is one of the primary reasons why we do not recommend using [variables](https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Variables) within your tests.\n\nInstead, Cypress commands **yield** their subjects.\n\nCypress commands are asynchronous and get queued for execution at a later time. While commands are executed, their subjects are **yielded** from one command to the next. This is because a lot of helpful Cypress code runs between each command to ensure everything is in order.\n\n## .then()\n\nSo if a command does not **return** a subject but instead **yields** it, how can you interact with the subject directly? You can interact with a subject directly by using <apiLink apiName=\"then\" displayName=\".then()\" />.\n\n`.then()` behaves similarly to Promises in JavaScript. However, <apiLink apiName=\"then\" displayName=\".then()\" /> is a Cypress command, **not a Promise**. This means you cannot use things like **async/await** within your Cypress tests.\n\nWhatever is returned from the callback function becomes the new subject and will flow into the following command (except for `undefined`).\n\n```js\ncy.get(\"button\").then(($btn) => {\n  const cls = $btn.attr(\"class\")\n\n  // ...\n})\n```\n\nWhen `undefined` is returned by the callback function, the subject will not be modified and will instead carry over to the next command.\n\nJust like Promises, you can return any compatible \"thenable\" (anything that has a <apiLink apiName=\"then\" displayName=\".then()\" /> interface), and Cypress will wait for that to resolve before continuing forward through the chain of commands.\n\nIf you're familiar with [native Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises), the Cypress <apiLink apiName=\"then\" displayName=\".then()\" /> works the same way.\n\n## .wrap()\n\nIn our example just above, `$btn` is a jQuery object. This means that if we would like Cypress to perform some action upon it, we first need to use <apiLink apiName=\"wrap\" displayName=\"cy.wrap()\" /> for Cypress to interact with it.\n\nThe example continued...\n\n```js\ncy.get(\"button\").then(($btn) => {\n  const cls = $btn.attr(\"class\")\n\n  cy.wrap($btn).click().should(\"not.have.class\", cls)\n})\n```\n\nIn this example, we are first getting the `<button>` HTML element. Our subject, which in this case is the `<button>` HTML element is yielded from <apiLink apiName=\"get\" displayName=\"cy.get()\" /> to <apiLink apiName=\"then\" displayName=\".then()\" />. We can then access the subject as the variable`$btn` , but first need to `.wrap()` it to perform whatever operations or assertions we would like on it.\n\nBefore our assertion, which in this case is `.should('not.have.class', cls)` we first need Cypress to <apiLink apiName=\"click\" displayName=\".click()\" /> the button. For Cypress to click on our `$btn`, we must first wrap it with <apiLink apiName=\"wrap\" displayName=\"cy.wrap()\" /> to provide the proper context for Cypress to perform the click.\n\nTo illustrate, we **cannot** do something like this, because `$btn` is a jQuery object.\n\n```js\n$btn.click().should(\"not.have.class\", cls) // Does not work\n```\n\nWe must use <apiLink apiName=\"wrap\" displayName=\"cy.wrap()\" /> first, because it provides Cypress the context necessary for interacting with the `$btn`.\n\n```js\ncy.wrap($btn).click().should(\"not.have.class\", cls)\n```\n\nTo learn more about the asynchronous nature of Cypress, please check the following sections of our docs.\n\n[Commands Are Asynchronous](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress#Commands-Are-Asynchronous)\n\n[The Cypress Command Queue](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress#The-Cypress-Command-Queue)\n\n[Return Values](https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Return-Values)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Understanding The Asynchronous Nature Of Cypress"},"url":"/cypress-fundamentals/understanding-the-asynchronous-nature-of-cypress","type":"lvl1"},{"title":"Waiting And Retry Ability","content":"# Waiting & Retry-ability\n\n## Retry-ability & Flake resistance\n\nRetry-ability is a core feature of Cypress and having a proper understanding of it is incredibly important. While most other testing tools require you to add \"hard\" waits, where you tell the tool to wait for a specified amount of time, Cypress will automatically wait for you. Since [Cypress runs in the browser](/cypress-fundamentals/cypress-runs-in-the-browser), it understands everything that is happening within your application.\n\nCypress is notified the moment the page loads and the moment it unloads. It is also notified of any events that are fired. Cypress is also smart enough to know how fast an element is animating and will wait for it to stop animating before acting upon it. It will also automatically wait until an element becomes visible, becomes enabled, or when another element is no longer covering it.\n\nCypress will pause executing any commands when a page transition happens until the new page has fully loaded.\n\n## Aliases\n\nIn Cypress, we use [Aliases](https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Aliases) to reference [elements](https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Elements), [requests](https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Requests), or [intercepts](https://docs.cypress.io/guides/core-concepts/variables-and-aliases#Intercepts) across our tests.\n\nTo create an alias use the <apiLink apiName=\"as\" displayName=\".as()\" /> function, like so:\n\n```js\n// Create an alias using the `as()` Cypress Command\ncy.get(\"table\").find(\"tr\").as(\"rows\")\n```\n\nThis will get the `<table>` HTML element, find all of the `<tr>` elements, and allow us to reference them as `@rows` throughout our tests.\n\nWe can access our alias using <apiLink apiName=\"get\" displayName=\"cy.get()\" /> by adding the `@` character before our alias name, like so:\n\n```js\n// Reference Cypress Alias `rows`\ncy.get(\"@rows\")\n```\n\n`@rows` is now a reference to the collection of `<tr>` elements that can be chained off of and interacted with as you would any other elements with Cypress.\n\n## Explicit Waits\n\nEven though Cypress is incredibly smart in handling automatic waiting, there are times when you explicitly want to wait for something. For example, you may want to wait on a specific network request to finish before moving forward. The best way to handle these waits is to wait on aliases. Anything that can be aliased can be waited upon, like elements, intercepts, requests, etc.\n\nLet's take a look at an example of what this looks like in practice.\n\n```js\ndescribe(\"User Sign-up and Login\", () => {\n  beforeEach(() => {\n    cy.request(\"POST\", \"/users\").as(\"signup\") // creating the signup alias\n  })\n\n  it(\"should allow a visitor to sign-up, login, and logout\", () => {\n    cy.visit(\"/\")\n    // ...\n\n    cy.wait(\"@signup\") // waiting upon the signup alias\n\n    // ...\n  })\n})\n```\n\nIn this example, we are creating an alias called **signup** for the POST request to the **/users** endpoint. Then within our test, we tell Cypress to wait upon the **signup** alias to complete before continuing on with our test.\n\nThe [Real World App](https://github.com/cypress-io/cypress-realworld-app) is full of examples of waiting upon aliases, and we go over several examples within the \"Real World Examples\" section later on.\n\nTo learn more about waiting and retry-ability, please check out the following sections of our docs:\n\n[Retry-ability](https://docs.cypress.io/guides/core-concepts/retry-ability)\n\n[Flake resistant](https://docs.cypress.io/guides/overview/key-differences#Flake-resistant)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Waiting And Retry Ability"},"url":"/cypress-fundamentals/waiting-and-retry-ability","type":"lvl1"},{"title":"Knowing What To Test","content":"# Knowing What to Test\n\nOne of the most difficult challenges when first learning how to write tests is understanding what you should be testing. If you already have a large application in production without any tests, how would you write tests for it? While each application is unique with its own set of features, functionality, technical debt, etc., here are some ways to help you determine what to test.\n\n## User Journeys\n\nIf you are trying to test an already existing application, we recommend that you begin by writing tests for your application's most \"mission-critical\" pieces. By \"mission-critical,\" we mean any portions of your application that cannot go down or break. For example, login/authentication, purchasing a product, processing a credit card, sign-up forms, etc. We recommend that your first suite of tests should be for these portions of your application and that they should be end-to-end tests.\n\nNow that you have identified the areas of your application that are most important, how exactly should you write your tests? We recommend writing tests for \"user journeys.\" User journeys are the essential paths in which a user of your application takes.\n\nFor example, let's say you have an e-commerce application. A user will first search for a product, add it to their shopping cart, fill out their shipping info, enter payment information, and finally purchase it. This entire flow a user takes from first finding a product to ultimately buying it is a user journey. The entire user journey should also be tested with a single test. The reason why it should be a single test, rather than several tests, which test each step in isolation, is so that you can make sure that all the pieces within your application are working correctly. Testing user journeys also tests all of the layers within your tech stack. You are testing the front-end and the back-end, the database layer, networking/API layers, etc.\n\nWith one test, you are testing the most critical pieces of your application, which will ultimately provide you with confidence that your application is behaving as it should.\n\n## New Features\n\nWhen you are implementing a new feature, a helpful technique for writing tests for that feature is to first start with the end goal in mind. What exactly does this feature need to do? What problem does it solve? Once you understand that, you can break the feature down into small incremental steps, all of which can be translated into tests.\n\nNow that you have a suite of tests for each step, you can write the code necessary to make each step pass. By doing this, you can also easily refactor this code later on as you will have the confidence from the tests that you have not broken anything during the refactor. If you have, your tests will fail.\n\n## Bugs\n\nIt is highly recommended that you write tests around any bug that appears in your application. A good approach is to first write a failing test around the bug before fixing it. Once the bug has been fixed your test will pass, which verifies that your new code has eliminated the bug.\n\nThis way, your test will help to ensure that this bug will never rear its ugly head in the future.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Knowing What To Test"},"url":"/testing-foundations/knowing-what-to-test","type":"lvl1"},{"title":"Manual Vs Automated Testing","content":"# Manual vs Automated Testing\n\n## Manual Testing\n\nManual testing involves someone, typically QA, physically interacting with an application. Manual testing is often very time-consuming as it requires someone repeating the same tasks over and over again, something that computers are incredibly good at.\n\nModern software development teams are shipping code into production multiple times a day, which is next to impossible if you are only manually testing. With the advance of Continuous Integration (CI) and Continuous Deployment (CD) modern software development teams are automating as much as possible, including testing, allowing them to push to production multiple times a day confidently.\n\n## Automated Testing\n\nAs more and more teams adopt CI/CD systems and want to push to production multiple times a day, automated tests are the only way to scale such demand.\n\nThere is currently a movement within software development known as \"[shift left](https://smartbear.com/learn/automated-testing/shifting-left-in-testing/).\" Shift left essentially means that the developers are increasingly becoming more involved with testing. Historically, testing was performed by a QA team at the very end of the development process. Now the industry is \"shifting left\" by having the responsibility of testing fall more and more upon the shoulders of developers. So instead of testing being an afterthought, it is now integrated into the entire software development lifecycle from the very beginning.\n\nTest automation is quickly becoming the \"norm\" for most software engineering teams, and its popularity and usefulness will only increase over time. If you do not have a lot of automated testing experience, you have come to the right place. We created Real World Testing with Cypress to teach you how to write automated tests, whether you are already a developer or a QA professional.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Manual Vs Automated Testing"},"url":"/testing-foundations/manual-vs-automated-testing","type":"lvl1"},{"title":"Testing Is A Mindset","content":"# Testing is a Mindset\n\nIt is critical to understand that testing is a mindset before we go any further. Testing methodologies, tools, frameworks, etc. are irrelevant if you first do not understand that testing is first and foremost, a mindset.\n\nThe reason why software development teams and QA teams are separate is because both teams view an application completely differently. Developers are responsible for building things, while QA professionals are responsible for breaking things. If developers want to write tests, they need to learn to think the way that a QA professional does and then translate that way of thinking into automated tests.\n\nNow that we understand that testing is a mindset, we need to discuss how this mindset plays out in the day to day work of software development. As new feature requests or bugs come in, you and your team should be thinking first about how you are going to test the application code related to these changes. These discussions should not be held in isolation, but should always incorporate both dev and QA teams. Even if your QA team is only doing manual testing, their input is incredibly valuable. They can help provide the test cases that they would expect to run against this new feature, which the developers can then translate said test cases into automated tests.\n\nIf you do not have a dedicated QA team, then the development team should be having discussions on what kinds of tests are going to be necessary to ensure this new feature is working correctly. An easy way to do this is to start with the end goal and work backwards. What does this new feature need to do? Once you understand that, you can break the problem down into small incremental steps, and translate those steps into tests. This way you have a clear path to achieve your goal and a suite of tests that will confirm everything is working properly.\n\nIf you are doing Agile, the test cases can be captured in the user stories as acceptance criteria for the story to be done.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Testing Is A Mindset"},"url":"/testing-foundations/testing-is-a-mindset","type":"lvl1"},{"title":"The Testing Pyramid","content":"# The Testing Pyramid\n\nThe testing pyramid illustrates the various types of tests and their relationship to one another. Developers can be pretty dogmatic and very strongly opinionated when it comes to testing, but remember, while definitions and labels can be helpful, ultimately, \"[it's not important what you call it, but what it does](https://web.archive.org/web/20150104002755/http://gojko.net/2011/01/12/the-false-dichotomy-of-tests)\" - Gojko Adzic.\n\n## Unit tests\n\nAt the base of the pyramid are unit tests. They are at the bottom because they are the foundation upon which your other tests rest.\n\nAs you can see, they take up the largest amount of space of the pyramid and are typically the tests that you will write the most.\n\nUnit tests are intended to test a single \"unit\" within an application. This means that they should not be dependent upon other parts of the system or application. Think of testing a single function, for example.\n\nWhen writing unit tests, you want to think of the function you are testing as a black box. You are not concerned with the logic inside of the function. You are only concerned that you expect a specific type of output given a specific type of input. This way, you can always refactor the internals or body of the function without breaking your tests.\n\nSo again, you are simply testing that given a set of inputs into this function, we expect this specific output. How that works internally is irrelevant for your testing purposes.\n\n## Integration tests\n\nThe point of integration testing is to ensure that individual pieces or units within an application work together as expected.\n\nUnlike unit tests, which should always be independent, integration tests are fundamentally dependent. Their entire purpose is to test the dependencies of pieces within a system are working together correctly.\n\nSo the distinction between a unit test and an integration test is that unit tests test things in isolation, and integration tests, are testing portions of your application that are related to one another, never in isolation.\n\nIntegration tests are great for when you are building a new application from scratch or an application or feature that does not have a UI yet. However, once you have a UI, that is when you should be writing end to end (E2E) tests.\n\n## End to End tests\n\nThese types of tests are written to test anything that runs in the browser. The purpose of these tests is to imitate what a real user would do.\n\nFor example, you might write a single test that registers a new account, logs in to that newly created account, purchases a product and then logs out. This way, you can ensure that all the layers within your application are working together correctly.\n\nEnd-to-end tests will often replace your integration tests, as they are essentially testing the same thing. However, E2E tests have an ever more significant advantage and value over integration tests, as they are testing real user interactions within your application.\n\n## Wrap Up\n\nCongrats! You have finished the second course of Real World Testing with Cypress. In the next course you will learn the fundamentals of Cypress.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"The Testing Pyramid"},"url":"/testing-foundations/the-testing-pyramid","type":"lvl1"},{"title":"Who Should Be Responsible For Testing","content":"# Who should be responsible for testing?\n\nUltimately, testing is everyone's responsibility.\n\nIn the real world, there are basically three team structures within modern software companies.\n\n## 1. Dedicated development and QA teams.\n\nCompanies with dedicated development and QA teams typically leave the software development up to the developers and testing to the QA team.\n\n## 2. Designer, Developer, QA, etc.\n\nSome companies will have small teams comprised of a developer, designer, QA engineer, etc., all working together on a single project or feature. In this scenario, the developer is typically responsible for the code, and QA is usually responsible for testing.\n\n## 3. Fullstack Solo Developer\n\nSome companies, like early-stage startups, do not have dedicated QA teams and put all of the testing responsibility on the developers. The developers are responsible for writing the code and ensuring that it works as expected.\n\nWhile many companies and teams have dedicated QA engineers, everyone is responsible for ensuring that an application is working as intended.\n\nIn order to ship reliable, high quality software, testing should be everyone's responsibility and should be at the thought process of the entire team at the start of a project.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Who Should Be Responsible For Testing"},"url":"/testing-foundations/who-should-be-responsible-for-testing","type":"lvl1"},{"title":"Cypress Command Logs Snapshots And Aliases","content":"# Cypress Command Logs, Snapshots and Aliases\n\nWhen writing custom [Cypress commands](https://docs.cypress.io/api/cypress-api/custom-commands), it is often helpful to output custom messages and information to the test runner with logging. Since Cypress commands are an abstraction, having proper logging reminds you of the context and purpose of the custom command.\n\nTo learn how to utilize `Cypress.log()`, we will update our **createDefaultTodos** command to log some helpful information.\n\nBefore we do that, let's update our test file to only run our **adds three todos** test. You can easily do this by appending `.only()` to our test, like so:\n\n```js\nit.only(\"adds three todos\", () => {\n  cy.createDefaultTodos()\n  cy.get(\".todo-list li\").should(\"have.length\", 3)\n})\n```\n\nThis will tell Cypress only to execute this test in our file. You can add `.only()` to multiple tests if you like.\n\nSave the file, and now Cypress is only running this specific test.\n\nWe are going to be updating our command by adding the following to it:\n\n```js\nCypress.log({\n  name: \"create default todos\",\n  consoleProps() {\n    return {\n      \"Inserted Todos\": [TODO_ITEM_ONE, TODO_ITEM_TWO, TODO_ITEM_THREE],\n    }\n  },\n})\n```\n\nBefore we do, however, let's go over what this is doing.\n\nFirst, we are passing an object to `Cypress.log()` with a name and `consoleProps()`. The `consoleProps()` function allows us to create our custom message that will be printed to our browser's console whenever we click on it within the test runner. We will see this in action shortly.\n\nNow let's update our custom command in **cypress/support/commands.js** , with our log.\n\n```js\nCypress.Commands.add(\"createDefaultTodos\", () => {\n  const TODO_ITEM_ONE = \"Buy Milk\"\n  const TODO_ITEM_TWO = \"Pay Rent\"\n  const TODO_ITEM_THREE = \"Pickup Dry Cleaning\"\n\n  Cypress.log({\n    name: \"create default todos\",\n    consoleProps() {\n      return {\n        \"Inserted Todos\": [TODO_ITEM_ONE, TODO_ITEM_TWO, TODO_ITEM_THREE],\n      }\n    },\n  })\n\n  cy.get(\".new-todo\")\n    .type(`${TODO_ITEM_ONE}{enter}`)\n    .type(`${TODO_ITEM_TWO}{enter}`)\n    .type(`${TODO_ITEM_THREE}{enter}`)\n})\n```\n\nAfter saving the file, you should see the following in the test runner:\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.18.03_AM.png)\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.19.14_AM.png)\n\nYou will see the name we passed to `Cypress.log()` at the top of our test body, and after clicking on it, you should see our custom message printed out to the dev console.\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.20.24_AM.png)\n\nThis is a handy way of providing additional information and context for what our custom command is doing.\n\nIf you look on the left hand side of the runner, within the test body, you will see some output that we don't actually need anymore. For instance, we don't need the runner to log out each time it types a new todo. We are already providing this information in our custom log message. We can prevent this output by passing `{ log: false }` like so:\n\n```js\ncy.get(\".new-todo\", { log: false })\n  .type(`${TODO_ITEM_ONE}{enter}`, { log: false })\n  .type(`${TODO_ITEM_TWO}{enter}`, { log: false })\n  .type(`${TODO_ITEM_THREE}{enter}`, { log: false })\n```\n\nSave the file, and now the output should be much cleaner.\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.25.26_AM.png)\n\n## Aliases\n\n[Aliases in Cypress](https://docs.cypress.io/guides/core-concepts/variables-and-aliases) provide a way for you to reference something later on in your test. You can think of it as a variable where you store something to use later on. Within our custom command to **createDefaultTodos**, we can return our newly created todos from the command, which we can then access as an alias within our test. Aliases can be used for all sorts of things, but in our case, we want to alias the todo elements or `<li>` from the DOM. This will make more sense when we break down the code involved and update our test to use this alias.\n\nThe first thing we want to do is store our newly created log into a variable.\n\n```js\nlet cmd = Cypress.log({\n  name: \"create default todos\",\n  consoleProps() {\n    return {\n      \"Inserted Todos\": [TODO_ITEM_ONE, TODO_ITEM_TWO, TODO_ITEM_THREE],\n    }\n  },\n})\n```\n\nThen, we get all of the **.todo-list** `<li>` elements, which are the three todos. We are also turning off logging for <apiLink apiName=\"get\" displayName=\"cy.get()\" /> in the test runner.\n\n```js\ncy.get(\".todo-list li\", { log: false })\n```\n\nNext, we are putting those elements\ninto a variable called `$listItems` which we then `.set()` on our `Cypress.log()`\n. Finally, we use <apiLink apiName=\"end\" displayName=\"cy.end()\" /> to let Cypress\nknow that our command is finished.\n\n```js\n.then(function ($listItems) {\n      cmd.set({ el: listItems }).snapshot().end()\n    })\n```\n\nThe entire command looks like this:\n\n```js\nCypress.Commands.add(\"createDefaultTodos\", () => {\n  const TODO_ITEM_ONE = \"Buy Milk\"\n  const TODO_ITEM_TWO = \"Pay Rent\"\n  const TODO_ITEM_THREE = \"Pickup Dry Cleaning\"\n\n  let cmd = Cypress.log({\n    name: \"create default todos\",\n    consoleProps() {\n      return {\n        \"Inserted Todos\": [TODO_ITEM_ONE, TODO_ITEM_TWO, TODO_ITEM_THREE],\n      }\n    },\n  })\n\n  cy.get(\".new-todo\", { log: false })\n    .type(`${TODO_ITEM_ONE}{enter}`, { log: false })\n    .type(`${TODO_ITEM_TWO}{enter}`, { log: false })\n    .type(`${TODO_ITEM_THREE}{enter}`, { log: false })\n\n  cy.get(\".todo-list li\", { log: false }).then((listItems) => {\n    cmd.set({ el: listItems }).snapshot().end()\n  })\n})\n```\n\nOur test should still pass after saving the file, but nothing has changed, as we are not using our todo items as an alias. Let's update one of our tests to take advantage of this alias.\n\nWe will be updating our test called **adds three todos** like so:\n\n```js\nit.only(\"adds three todos\", () => {\n  cy.createDefaultTodos().as(\"todos\")\n  cy.get(\"@todos\").should(\"have.length\", 3)\n})\n```\n\nAfter saving the file, our test is still passing, and the runner has also logged our new alias.\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.48.45_AM.png)\n\nNow the test runner states explicitly that our <apiLink apiName=\"get\" displayName=\"cy.get()\" /> is getting **@todos** which is the alias we just created.\n\n## Snapshot\n\nBefore we wrap up this lesson, we would like to introduce you to the `.snapshot()` method. Currently, when you click on our custom **createDefaultTodos** command in the test runner, you will see the following.\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.52.41_AM.png)\n\nThere isn't any UI on the right-hand side, even though the runner says \"DOM Snapshot (pinned)\" at the bottom. The reason being is that we have not told Cypress to specifically take a snapshot of the DOM in our custom command. We can easily update our command like so to get what we need.\n\n```js\ncy.get(\".todo-list li\", { log: false }).then((listItems) => {\n  cmd.set({ el: listItems }).snapshot().end()\n})\n```\n\nAfter saving the file, you should now see the following:\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.54.26_AM.png)\n\nNext to the \"DOM Snapshot (pinned),\" you will see two buttons with a 1 and 2, respectively. Button 1 is selected by default and doesn't display anything. However, clicking on button two will show a snapshot of the DOM with our three newly created todos.\n\n![](/images/testing-your-first-application/cypress-command-logs-snapshots-and-aliases/Screen_Shot_2021-06-28_at_10.54.29_AM.png)\n\n## Practice\n\nNow that you have seen how aliases work, try it on your own. Update the **should append new items to the bottom of the list** test to use an alias as we did in the **adds three todos** test.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Cypress Command Logs Snapshots And Aliases"},"url":"/testing-your-first-application/cypress-command-logs-snapshots-and-aliases","type":"lvl1"},{"title":"How To Use Cypress Commands","content":"# How to use Cypress Commands\n\nWe are starting to make excellent progress thus far, but we have even more exciting things to learn. Within this lesson, we are going to learn about [Cypress commands](https://docs.cypress.io/api/cypress-api/custom-commands). Cypress commands are custom commands that we can write ourselves to make portions of our test code re-usable.\n\n[Cypress commands](https://docs.cypress.io/api/cypress-api/custom-commands) are incredibly useful. As your test suite grows, you will find yourself reaching for them more and more to help simplify and re-use portions of your test code.\n\nFor our specific use case, let's write a custom Cypress command that will create some default todos for us. This way, we will have a single line of code that will generate some todos in our app each time we use it.\n\nOpen the **cypress/support/commands.js** file and write the following.\n\n```js\nCypress.Commands.add(\"createDefaultTodos\", () => {})\n```\n\nLet's first copy the variables from our test file into this new command.\n\n```js\nCypress.Commands.add(\"createDefaultTodos\", () => {\n  const TODO_ITEM_ONE = \"Buy Milk\"\n  const TODO_ITEM_TWO = \"Pay Rent\"\n  const TODO_ITEM_THREE = \"Pickup Dry Cleaning\"\n})\n```\n\nNow let's add the ability to create our todos.\n\n```js\nCypress.Commands.add(\"createDefaultTodos\", () => {\n  const TODO_ITEM_ONE = \"Buy Milk\"\n  const TODO_ITEM_TWO = \"Pay Rent\"\n  const TODO_ITEM_THREE = \"Pickup Dry Cleaning\"\n\n  cy.get(\".new-todo\")\n    .type(`${TODO_ITEM_ONE}{enter}`)\n    .type(`${TODO_ITEM_TWO}{enter}`)\n    .type(`${TODO_ITEM_THREE}{enter}`)\n})\n```\n\nNow let's update our second test to use this new command.\n\n```js\nit(\"adds three todos\", () => {\n  cy.createDefaultTodos()\n  cy.get(\".todo-list li\").should(\"have.length\", 3)\n})\n```\n\n![](/images/testing-your-first-application/how-to-use-cypress-commands/Screen_Shot_2021-06-25_at_12.02.31_PM.png)\n\nGreat, our tests are still passing and our new command is working perfectly.\n\n# Testing the order in which todos are added\n\nNow let's write a simple test to ensure each todo is added in the correct order, which means that each new todo is appended to the bottom of the list.\n\nFirst we will create a new `it()` block.\n\n```js\nit(\"should append new items to the bottom of the list\", () => {})\n```\n\nNext we can use our new `createDefaultTodos()` to add some todo's to the app.\n\n```js\nit(\"should append new items to the bottom of the list\", () => {\n  cy.createDefaultTodos()\n})\n```\n\n![](/images/testing-your-first-application/how-to-use-cypress-commands/Screen_Shot_2021-06-25_at_12.08.55_PM.png)\n\nNow let's make some assertions to make sure each todo is in the correct order.\n\n```js\nit(\"should append new items to the bottom of the list\", () => {\n  cy.createDefaultTodos()\n\n  // Todo 1\n  cy.get(\".todo-list li\").eq(0).find(\"label\").should(\"contain\", TODO_ITEM_ONE)\n\n  // Todo 2\n  cy.get(\".todo-list li\").eq(1).find(\"label\").should(\"contain\", TODO_ITEM_TWO)\n\n  // Todo 3\n  cy.get(\".todo-list li\").eq(2).find(\"label\").should(\"contain\", TODO_ITEM_THREE)\n})\n```\n\nAll tests are still passing.\n\nWhile we are at it, we can also assert that three todos have been added. However, let's do it differently than before.\n\nIn our previous tests we are asserting the number of todo's like so:\n\n```js\ncy.get(\".todo-list li\").should(\"have.length\", 3)\n```\n\nThis is entirely valid, but there is also another way.\n\nWithin the bottom left-hand corner of our app is some text that says \"x items left,\" where x is the current number of todos left to be completed.\n\nLet's assert that this text is displaying the correct message and number of todos.\n\n![](/images/testing-your-first-application/how-to-use-cypress-commands/Screen_Shot_2021-06-25_at_12.16.12_PM.png)\n\nAfter finding the element with our dev tools, we can write the assertion like so:\n\n```js\ncy.get(\".todo-count\").contains(\"3 items left\")\n```\n\nSo our entire test now looks like this:\n\n```js\nit(\"should append new items to the bottom of the list\", () => {\n  cy.createDefaultTodos()\n\n  // Todo 1\n  cy.get(\".todo-list li\").eq(0).find(\"label\").should(\"contain\", TODO_ITEM_ONE)\n\n  // Todo 2\n  cy.get(\".todo-list li\").eq(1).find(\"label\").should(\"contain\", TODO_ITEM_TWO)\n\n  // Todo 3\n  cy.get(\".todo-list li\").eq(2).find(\"label\").should(\"contain\", TODO_ITEM_THREE)\n\n  cy.get(\".todo-count\").contains(\"3 items left\")\n})\n```\n\nYou will notice that our **.todo-count** is a `<span>` with multiple elements nested inside of it. The number is wrapped in a `<strong>` tag, and the words are wrapped in `<span>` tags. The <apiLink apiName=\"contains\" displayName=\"cy.contains()\" /> method will find the appropriate text even though it may be nested in several different tags.\n\nIn the above example, we use both <apiLink apiName=\"should\" displayName=\"cy.should()\" />, and <apiLink apiName=\"contains\" displayName=\"cy.contains()\" />.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"How To Use Cypress Commands"},"url":"/testing-your-first-application/how-to-use-cypress-commands","type":"lvl1"},{"title":"Installing Cypress And Writing Our First Test","content":"# Installing Cypress and writing our first test\n\n## Installing Cypress\n\nBefore we can begin writing our tests, we first need to install Cypress into our project. You can find more details about the installation process [here](https://docs.cypress.io/guides/getting-started/installing-cypress).\n\nWe can add Cypress to our project with the following command:\n\n```bash\nyarn add Cypress -D\n```\n\nNext we will add a custom npm script so we can launch Cypress easily. The entire \"scripts\" object within **package.json** should look like this:\n\n```json\n\"scripts\": {\n  \"cypress:open\": \"cypress open\",\n  \"start\": \"http-server -p 8888 -c-1\"\n},\n```\n\nBefore we run our new script, make sure also to have the application running in a separate terminal window. It is vital to have the application up and running as Cypress cannot execute any tests without it.\n\nIf you are using VSCode, you can open the built-in terminal with (Ctrl+` on Mac/Win). Or you can click on View > Terminal in the menu at the top.\n\nIn your terminal enter the following command to start the app.\n\n```bash\nyarn start\n```\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-09-17_at_10.09.16_AM.png)\n\nLet's now start Cypress so that it can create the directories and files within our project.\n\n```bash\nyarn cypress:open\n```\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-09-17_at_10.09.40_AM.png)\n\nMake sure to keep Cypress running through the duration of this lesson.\n\nWhen Cypress first launches, it will display some helpful information on a screen like this:\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_9.47.49_AM.png)\n\nClick on the green \"Ok, got it!\" button to close the modal.\n\nCypress automatically creates several example spec files for you. If this is your first time using Cypress, we highly recommend that you click on some of them to see the Cypress test runner in action. You can find them within **cypress/integration/examples**.\n\nDon't worry if you don't understand them yet or feel a bit overwhelmed. We will be writing our own tests shortly, and we will explain every line of code along the way.\n\n## Selecting a browser\n\nYou can select which browser Cypress should use in the upper right-hand corner. Cypress will automatically detect all of the installed browsers on your machine, so choose whichever you would like for it to use.\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_9.56.26_AM.png)\n\n## Writing our first test\n\nNow that we have Cypress installed and working let's write our first test for our todo application.\n\nCreate a new file called **app.spec.js** within the **cypress/integration** directory.\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.02.58_AM.png)\n\nInside that file, we will use the `describe()` function to help us organize our tests. Let's use it to create a describe block called \"React TodoMVC.\"\n\n```js\ndescribe(\"React TodoMVC\", () => {})\n```\n\nWithin that describe block, we will write our tests using the `it()` function. For our first test, let's write a test to assert that we can add a single todo.\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {})\n})\n```\n\nWithin the body of our `it()` function is where we write the code necessary for our test to run. Before we begin to do that, let's take a step back and think through all of the steps necessary to add a single todo.\n\nOpen the app in your browser and note all of the steps you need to perform to add a single todo.\n\n1. We need to focus on the input field.\n2. We need to enter in the name of our todo.\n3. We need to press the enter key to add our todo.\n\nNow let's write out these steps into our test.\n\nBefore having Cypress click into the input field, we first need to grab the input field element from the DOM, so Cypress knows which element to click.\n\nIf we inspect the element with our browser's dev tools, we will notice that the input field has a class of **new-todo** .\n\n```js\n<input class=\"new-todo\" placeholder=\"What needs to be done?\" data-reactid=\".0.0.1\">\n```\n\nTherefore we can <apiLink apiName=\"get\" displayName=\"cy.get()\" /> this element like so:\n\n```js\ncy.get(\".new-todo\")\n```\n\nSo our entire test file should now look like this:\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.get(\".new-todo\")\n  })\n})\n```\n\nWhen Cypress launches, you will see several example files, so toggle the small arrow to the left of the **examples** folder to collapse that folder. You can also click the \"COLLAPSE ALL\" button to collapse everything.\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.20.05_AM.png)\n\nNow click on the **app.spec.js** file to launch the file containing our test.\n\nYou should see an error like this:\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.20.58_AM.png)\n\nCypress is telling us that it is unable to <apiLink apiName=\"get\" displayName=\"cy.get()\" /> our input element with the class of **.new-todo**. If you look at the right side of Cypress, you will see a message that says, \"This is the default blank page,\" with some hints about what to do. This is just a blank page that Cypress opens when it doesn't know where to go, but we want Cypress to open our todo application. Let's go back to our test and tell Cypress how to navigate to our app.\n\nWe can use the <apiLink apiName=\"visit\" displayName=\"cy.visit()\" /> method to tell Cypress which URL to visit:\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\")\n  })\n})\n```\n\nCypress provides an excellent developer experience in that each time we save our test file, the runner will automatically re-run all of our tests. So after saving our file, you should now see the following:\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.25.30_AM.png)\n\nThe green checkmark in the Cypress Command Log, on the left side of the screen, means that Cypress has successfully found the input with the class of **new-todo**.\n\nNext, we need to enter the name of our todo. We can do that using the <apiLink apiName=\"type\" displayName=\"cy.type()\" /> method and passing in a string of what we would like Cypress to type into the input.\n\n```js\ncy.get(\".new-todo\").type(\"Buy Milk\")\n```\n\nAfter saving our file, Cypress will re-run our test, and you should see the following:\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.27.18_AM.png)\n\nNext, we need to simulate the user pressing the **enter** key to add the todo.\n\n```js\ncy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n```\n\nBy adding `{enter}` inside of our <apiLink apiName=\"type\" displayName=\"cy.type()\" /> function, Cypress will press the enter key after it has finished typing \"Buy Milk\"\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.29.13_AM.png)\n\nSo our entire test file should like this so far:\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n  })\n})\n```\n\nWith just a few lines of code, we have written our first test that confirms that we can add a single todo to our application.\n\nBefore we wrap this up, however, I want you to think about this question, \"How do we know only a single todo has been added?\" Our test confirms that we can add a single todo, but how do we know for sure that only a single todo exists? We need a way to assert that only a single todo can be added. Let's see how we can do this.\n\nFirst, let's use our dev tools to inspect our newly added todo.\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.37.43_AM.png)\n\nWe can see that our todos are added as `<li>` elements. Knowing this, we can make an assertion that only a single `<li>` element exists within our todo app like so:\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n})\n```\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.39.45_AM.png)\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.40.23_AM.png)\n\nLet's break down what this line of code is doing.\n\n```js\ncy.get(\".todo-list li\")\n```\n\nFirst, we are getting all of the `<li>` child elements of the **.todo-list** element. This will return an array of all of the child elements that it finds, which in our case should only be 1.\n\nWe then assert that this array should have a length of 1 element.\n\n```js\ncy.get(\".todo-list li\").should(\"have.length\", 1)\n```\n\nLet's update our test to add two todos to see if our assertion now fails.\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n    cy.get(\".new-todo\").type(\"Pay Rent{enter}\")\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n})\n```\n\nOur assertion fails because we have more than one todo now.\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.48.50_AM.png)\n\nWe can also simplify this code by chaining both of our <apiLink apiName=\"type\" displayName=\"cy.type()\" /> functions together like so:\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\").type(\"Pay Rent{enter}\")\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n})\n```\n\nThis is just a handy way of not getting the same element multiple times, and it also cleans up our test a little bit.\n\nNow let's update our test so that we are only adding a single todo and everything passes.\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n})\n```\n\n![](/images/testing-your-first-application/installing-cypress-and-writing-our-first-test/Screen_Shot_2021-06-25_at_10.51.41_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Installing Cypress And Writing Our First Test"},"url":"/testing-your-first-application/installing-cypress-and-writing-our-first-test","type":"lvl1"},{"title":"Setting Up Data Before Each Test","content":"# Setting up Data Before Each Test\n\nOur first test makes sure that a single todo can be added to our application. However, a todo app that only takes a single todo is useless. So let's write a test to make sure our app can add multiple todos.\n\nFirst, we need to create another `it()` function to test adding three todos.\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  it(\"adds a single todo\", () => {\n    cy.visit(\"http://localhost:8888\")\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n\n  it(\"adds three todos\", () => {})\n})\n```\n\nRemember, the first thing we need to do is to tell Cypress to <apiLink apiName=\"visit\" displayName=\"cy.visit()\" /> to our app. Each `it()` function is a separate test, so for each new test we write, we have to specifically tell Cypress to <apiLink apiName=\"visit\" displayName=\"cy.visit()\" /> our application.\n\nYou may start to see a potential annoyance here. Granted, since we only have two tests right now, this is not that big of a deal, but what if our test file had several tests. This would mean that within every single `it()`, we would have to specifically tell Cypress to navigate to our app for each test, which is very repetitive and annoying. There is a better way, fortunately.\n\n## beforeEach()\n\nThe `beforeEach()` function, which is provided by [Mocha](https://mochajs.org/), is perfect for code that you want to execute before every test. Let's update our test file to use it, like so:\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  beforeEach(() => {\n    cy.visit(\"http://localhost:8888\")\n  })\n\n  it(\"adds a single todo\", () => {\n    cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n\n  it(\"adds three todos\", () => {})\n})\n```\n\nBoth tests are still passing with this simple update, and we have cleaned up our duplicate code.\n\n## Multiple Todos\n\nNow let's update our **adds three todos** test to add three todos.\n\n```js\nit(\"adds three todos\", () => {\n  cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n  cy.get(\".new-todo\").type(\"Pay Rent{enter}\")\n  cy.get(\".new-todo\").type(\"Pickup Dry Cleaning{enter}\")\n})\n```\n\n![](/images/testing-your-first-application/setting-up-data-before-each-test/Screen_Shot_2021-06-25_at_11.19.56_AM.png)\n\nGreat our application can easily handle adding three todos.\n\nHowever, you may have noticed we are repeating ourselves once again.\n\n```js\nit(\"adds a single todo\", () => {\n  cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n  cy.get(\".todo-list li\").should(\"have.length\", 1)\n})\n\nit(\"adds three todos\", () => {\n  cy.get(\".new-todo\").type(\"Buy Milk{enter}\")\n  cy.get(\".new-todo\").type(\"Pay Rent{enter}\")\n  cy.get(\".new-todo\").type(\"Pickup Dry Cleaning{enter}\")\n})\n```\n\nInstead of having to manually type out and hard code each and every todo, we can simply put them into a variable. Remember, Cypress is just JavaScript, so let's refactor the names of our todos into constants so we can easily re-use them.\n\nWe will create variables at the top of our test, just underneath the `describe()` block.\n\n```js\ndescribe('React TodoMVC', () => {\n  const TODO_ITEM_ONE = 'Buy Milk'\n  const TODO_ITEM_TWO = 'Pay Rent'\n  const TODO_ITEM_THREE = 'Pickup Dry Cleaning'\n\n  beforeEach(() => {\n    cy.visit('http://localhost:8888')\n  })\n\n// ...\n```\n\nThen we can update our todos to use these new variables.\n\n```js\ndescribe(\"React TodoMVC\", () => {\n  const TODO_ITEM_ONE = \"Buy Milk\"\n  const TODO_ITEM_TWO = \"Pay Rent\"\n  const TODO_ITEM_THREE = \"Pickup Dry Cleaning\"\n\n  beforeEach(() => {\n    cy.visit(\"http://localhost:8888\")\n  })\n\n  it(\"adds a single todo\", () => {\n    cy.get(\".new-todo\").type(`${TODO_ITEM_ONE}{enter}`)\n    cy.get(\".todo-list li\").should(\"have.length\", 1)\n  })\n\n  it(\"adds three todos\", () => {\n    cy.get(\".new-todo\").type(`${TODO_ITEM_ONE}{enter}`)\n    cy.get(\".new-todo\").type(`${TODO_ITEM_TWO}{enter}`)\n    cy.get(\".new-todo\").type(`${TODO_ITEM_THREE}{enter}`)\n  })\n})\n```\n\nMuch better. Now we can easily re-use these todos throughout our tests.\n\nFinally, let's add an assertion like we did in our first test to make sure only three todo's have been added. Like so:\n\n```js\nit(\"adds three todos\", () => {\n  cy.get(\".new-todo\").type(`${TODO_ITEM_ONE}{enter}`)\n  cy.get(\".new-todo\").type(`${TODO_ITEM_TWO}{enter}`)\n  cy.get(\".new-todo\").type(`${TODO_ITEM_THREE}{enter}`)\n  cy.get(\".todo-list li\").should(\"have.length\", 3)\n})\n```\n\nAnd all of our tests are passing. Awesome!\n\n## Making our tests more robust\n\nSo we currently have two tests, one that adds a single todo and another that adds multiple todos. This is great and useful, but we can take these tests further to make them even more robust. For example, shouldn't we also test that the todos render the correct text within the app? That seems valuable to test, so let's update our tests to do just that.\n\nLet's first try this out by updating our first test, which adds a single todo. Once we get it working, we can add this assertion to the other test.\n\nIf we inspect our app with our dev tools again, we want to ensure that the text that we enter into the input field is rendered exactly as one of our todos. We can see that within each `<li>` each todo name is wrapped in a `<label>` element.\n\n![](/images/testing-your-first-application/setting-up-data-before-each-test/Screen_Shot_2021-06-25_at_11.32.00_AM.png)\n\nKnowing this, we can assert that our todo's name is within this `<label>` element.\n\nFirst we need to get all of the `<li>` elements.\n\n```js\ncy.get(\".todo-list li\")\n```\n\nThen we want to make sure we grab the first element in this array. We can do that by using the <apiLink apiName=\"eq\" displayName=\".eq()\" /> method.\n\n```js\ncy.get(\".todo-list li\").eq(0)\n```\n\nWe then pass <apiLink apiName=\"eq\" displayName=\".eq()\" /> the index of our element, which should be the first one, and it will return that element from the array.\n\nThen we will use the [find()](https://docs.cypress.io/api/commands/find) method to find our `<label>` element.\n\n```js\ncy.get(\".todo-list li\").eq(0).find(\"label\")\n```\n\nThe <apiLink apiName=\"find\" displayName=\".find()\" /> method will look for child elements of a specific selector.\n\nSo, we are getting the first `<li>` element from the **.todo-list** element and then within that `<li>` element we are looking for the `<label>` element.\n\nFinally, we want to make sure that the `<label>` contains the text of our todo item.\n\n```js\ncy.get(\".todo-list li\").eq(0).find(\"label\").should(\"contain\", TODO_ITEM_ONE)\n```\n\nSave the file and let the tests run again.\n\n![](/images/testing-your-first-application/setting-up-data-before-each-test/Screen_Shot_2021-06-25_at_11.40.52_AM.png)\n\nGreat, everything is green and passing.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Setting Up Data Before Each Test"},"url":"/testing-your-first-application/setting-up-data-before-each-test","type":"lvl1"},{"title":"Testing What Isnt There","content":"# Testing what isn't there\n\nUp until this point, we have been writing tests and assertions to make sure that things are displayed correctly. For instance, the **should append new items to the bottom of the list** test makes sure that our todos are listed in the correct order and that the todo count text is correct.\n\nThis is all well and good, but it is also important to write tests to ensure that things are _not_ shown when they are not supposed to be. So, in addition to testing the positive case, make sure also to test the negative.\n\nThis will make more sense when we write our first \"negative\" test. For instance, when a todo is added to the application, a `<footer>` is appended to the bottom of the app. When there are no todos, the `<footer>` is removed.\n\nLet's write a test to ensure that the `<footer>` is not visible to our users when there are no todos.\n\n```js\nit(\"does NOT display the footer when there are no todos\", () => {})\n```\n\nNow let's grab the `<footer>` element and write an assertion that it does not exist when there are no todos.\n\n```js\ncy.get(\".footer\").should(\"not.exist\")\n```\n\n![](/images/testing-your-first-application/testing-what-isnt-there/Screen_Shot_2021-06-25_at_2.33.00_PM.png)\n\nGreat, our test is passing. Let's also think of some other elements that should not exist when there are no todos.\n\nAnother element that should not exist is our **.todo-list** element. Let's write another assertion to ensure that this does not exist if there are no todos.\n\n```js\ncy.get(\".todo-list\").should(\"not.exist\")\n```\n\nSince we are now checking for multiple elements, let's update our test name to be more explicit.\n\n```js\nit(\"does NOT display the footer or todo-list when there are no todos\", () => {\n  cy.get(\".footer\").should(\"not.exist\")\n  cy.get(\".todo-list\").should(\"not.exist\")\n})\n```\n\n## Practice\n\nFor additional practice checkout the **cypress/integration/practice/practice.spec.js** file in the TodoMVC repo. This file contains several tests, with helpful comments, to help you put into practice all of the concepts you have learned so far.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/final/practice.spec.js**\n\n## Wrap Up\n\nCongrats! You have finished the first course of Real World Testing with Cypress. In the next course you will learn all of the fundamentals you need to write great tests.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Testing What Isnt There"},"url":"/testing-your-first-application/testing-what-isnt-there","type":"lvl1"},{"title":"Todomvc App Install And Overview","content":"# TodoMVC App Install & Overview\n\nThe application we will be writing tests for can be found [here](https://github.com/cypress-io/cypress-realworld-testing-todomvc). The app is a TodoMVC application built with React. Don't worry if you do not know React. You can still follow along even if you have never used React before.\n\n## Install\n\nThe first thing you need to do is to clone the [TodoMVC repo](https://github.com/cypress-io/cypress-realworld-testing-todomvc).\n\n```bash\ngit clone git@github.com:cypress-io/cypress-realworld-testing-todomvc.git\n```\n\nYou can also download a .zip file of the repo by clicking on the green \"Code\" button and then \"Download Zip.\"\n\n![](/images/testing-your-first-application/todomvc-app-install-and-overview/Screen_Shot_2021-10-21_at_10.13.11-AM.png)\n\nNext, you will need to open the repo in your text editor. We will be using [VS Code](https://code.visualstudio.com/), but feel free to use any text editor you like.\n\nYou can install all of the dependencies by typing the following in the terminal.\n\n```bash\nyarn install\n```\n\nMake sure to be using a version of Node that is `v.14` or higher and use [Yarn package manager](https://yarnpkg.com/).\n\nIf you don't have Yarn installed, you can install it with this command:\n\n```bash\nnpm install --global yarn\n```\n\n![](/images/testing-your-first-application/todomvc-app-install-and-overview/Screen_Shot_2021-09-17_at_10.13.32_AM.png)\n\nThen to start the app:\n\n```bash\nyarn start\n```\n\n![](/images/testing-your-first-application/todomvc-app-install-and-overview/Screen_Shot_2021-09-17_at_10.13.44_AM.png)\n\nYou can then open your browser to the HTTP server URL shown in the console (e.g. **http://localhost:8888**), and you should see the following:\n\n![](/images/testing-your-first-application/todomvc-app-install-and-overview/Screen_Shot_2021-06-24_at_1.08.11_PM.png)\n\n## App Overview\n\n![](/images/testing-your-first-application/todomvc-app-install-and-overview/Screen_Shot_2021-06-24_at_1.14.12_PM.png)\n\nThe app is a basic todo app where you can add todos, complete todos, and filter todos based upon their active or completed state. Take some time to play around with the app to get a sense of the overall functionality.\n\nTesting is a mindset, so before we can begin to write tests for our app, we first need to understand what we need to test and why. To find out what to test, we need to think about the core functionality of the application. Ask yourself the question, \"what are some of the most important features of this app?\" Start by breaking down the features and functionality of the app into individual pieces. The \" why \" should become much clearer once you understand some of the core functionality and features.\n\nFor example, since this is a todo application, one of the most important features should be adding todos. If a user is not able to add todos, the entire app is useless. Therefore, one of the first things we should test is that a user can add todos.\n\nIn the next lesson, we will learn how to install Cypress and write our first test to make sure we can add a todo to the app.\n\n## Practice\n\nAfter completing all of the lessons in this tutorial, make sure to check out the **cypress/integration/practice/practice.spec.js** file. This file contains several tests, with helpful comments, to help you put into practice all of the concepts you will learn in this tutorial.\n\nShould you get stuck or need some help, all of the answers are provided within **cypress/integration/final/practice.spec.js**\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Todomvc App Install And Overview"},"url":"/testing-your-first-application/todomvc-app-install-and-overview","type":"lvl1"},{"title":"Authentication Overview And Setup","content":"# Authentication Overview & Setup\n\nIn this section, we will be discussing the various tests located within the **cypress/tests/ui/auth.spec.ts** file.\n\nLet's break down what is happening within the `beforeEach()` as it is important to understand what is going on since this hook is running before each test.\n\n## beforeEach()\n\n```js\nbeforeEach(function () {\n  cy.task(\"db:seed\")\n\n  cy.intercept(\"POST\", \"/users\").as(\"signup\")\n  cy.intercept(\"POST\", apiGraphQL, (req) => {\n    const { body } = req\n\n    if (\n      body.hasOwnProperty(\"operationName\") &&\n      body.operationName === \"CreateBankAccount\"\n    ) {\n      req.alias = \"gqlCreateBankAccountMutation\"\n    }\n  })\n})\n```\n\nYou can find out more information about the custom Cypress commands used [here](/real-world-examples/custom-cypress-commands).\n\nThe first thing that happens inside of this hook is a custom task we have created called `db:seed` which is responsible for seeding our database.\n\n```js\ncy.task(\"db:seed\")\n```\n\nNext, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept every **POST** request to the **/users** route. We are then aliasing this intercept to \"signup.\" When you see `@signup` being used within a test, it is referring to this intercept.\n\n```js\ncy.intercept(\"POST\", \"/users\").as(\"signup\")\n```\n\nFinally, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept every **POST** request to our GraphQL API endpoint. Within the body of this intercept, we have a conditional to check to see if the GraphQL `operationName` is equal to \"CreateBankAccount,\" if so, we are creating an alias to this intercept as `gqlCreateBankAccountMutation` . When you see `@gqlCreateBankAccountMutation` being used within a test, it is referring to this intercept.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Authentication Overview And Setup"},"url":"/real-world-examples/authentication-overview-and-setup","type":"lvl1"},{"title":"Invalid Users","content":"# Invalid Users\n\nBefore continuing, make sure you have read the [Authentication Overview & Setup](/real-world-examples/authentication-overview-and-setup) lesson first.\n\n```js\nit(\"should error for an invalid user\", function () {\n  cy.login(\"invalidUserName\", \"invalidPa$$word\")\n\n  cy.getBySel(\"signin-error\")\n    .should(\"be.visible\")\n    .and(\"have.text\", \"Username or password is invalid\")\n  cy.visualSnapshot(\n    \"Sign In, Invalid Username and Password, Username or Password is Invalid\"\n  )\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we are using `cy.login()`, a Custom Cypress Command to use the Sign In UI to log in as a user with an invalid username and password.\n\n```js\ncy.login(\"invalidUserName\", \"invalidPa$$word\")\n```\n\nFinally, we confirm the error is displayed. The correct error message is shown with a chained expectation that the error is visible and has a specific error message.\n\n```js\ncy.getBySel(\"signin-error\")\n  .should(\"be.visible\")\n  .and(\"have.text\", \"Username or password is invalid\")\n```\n\n![](/images/real-world-examples/authentication/invalid-users/Screen_Shot_2021-06-28_at_1.50.00_PM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Invalid Users"},"url":"/real-world-examples/invalid-users","type":"lvl1"},{"title":"Login Errors","content":"# Login Errors\n\nBefore continuing, make sure you have read the [Authentication Overview & Setup](/real-world-examples/authentication-overview-and-setup) lesson first.\n\n```js\nit(\"should display login errors\", function () {\n  cy.visit(\"/\")\n\n  cy.getBySel(\"signin-username\").type(\"User\").find(\"input\").clear().blur()\n  cy.get(\"#username-helper-text\")\n    .should(\"be.visible\")\n    .and(\"contain\", \"Username is required\")\n  cy.visualSnapshot(\"Display Username is Required Error\")\n\n  cy.getBySel(\"signin-password\").type(\"abc\").find(\"input\").blur()\n  cy.get(\"#password-helper-text\")\n    .should(\"be.visible\")\n    .and(\"contain\", \"Password must contain at least 4 characters\")\n  cy.visualSnapshot(\"Display Password Error\")\n\n  cy.getBySel(\"signin-submit\").should(\"be.disabled\")\n  cy.visualSnapshot(\"Sign In Submit Disabled\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nAn unwritten assertion of this test is to ensure that the application redirects to the Sign In page if not logged in.\n\n```js\ncy.visit(\"/\")\n```\n\n## Username\n\nOnce redirected, we get the username input field, then typing in a user name of `jdoe`.\n\n```js\ncy.getBySel(\"signin-username\").type(\"jdoe\").find(\"input\").clear().blur()\n```\n\nWe then <apiLink apiName=\"find\" displayName=\".find()\" /> the input as the element we are actually selecting is a div that is wrapping our input.\n\nWe then clear the input field and trigger a blur event which triggers the validation.\n\nNext, we confirm that our validation is displaying the correct error message with the following assertion.\n\n```js\ncy.get(\"#username-helper-text\")\n  .should(\"be.visible\")\n  .and(\"contain\", \"Username is required\")\n```\n\n![](/images/real-world-examples/authentication/login-errors/Screen_Shot_2021-06-28_at_1.40.59_PM.png)\n\n## Password\n\nWe want to test the same behavior for the password input as we did for the username input.\n\nWe make sure our validation fires when the user blurs out of the input.\n\n```js\ncy.getBySel(\"signin-password\").type(\"abc\").find(\"input\").blur()\n```\n\nThen we will make sure the error message is displayed and has the correct message.\n\n```js\ncy.get(\"#password-helper-text\")\n  .should(\"be.visible\")\n  .and(\"contain\", \"Password must contain at least 4 characters\")\n```\n\nFinally, we want to make sure that our sign in button is disabled. Anytime we have errors on this screen, the user should not be able to click the sign in button.\n\n```js\ncy.getBySel(\"signin-submit\").should(\"be.disabled\")\n```\n\n![](/images/real-world-examples/authentication/login-errors/Screen_Shot_2021-06-28_at_1.42.18_PM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Login Errors"},"url":"/real-world-examples/login-errors","type":"lvl1"},{"title":"Sign Up Login Create Bank Account And Logout","content":"# Sign-up, Login, Create Bank Account and Logout\n\nBefore continuing, make sure you have read the [Authentication Overview & Setup](/real-world-examples/authentication-overview-and-setup) lesson first.\n\n```js\nit(\"should allow a visitor to sign-up, login, and logout\", function () {\n  const userInfo = {\n    firstName: \"Bob\",\n    lastName: \"Ross\",\n    username: \"PainterJoy90\",\n    password: \"s3cret\",\n  }\n\n  // Sign-up User\n  cy.visit(\"/\")\n\n  cy.getBySel(\"signup\").click()\n  cy.getBySel(\"signup-title\").should(\"be.visible\").and(\"contain\", \"Sign Up\")\n  cy.visualSnapshot(\"Sign Up Title\")\n\n  cy.getBySel(\"signup-first-name\").type(userInfo.firstName)\n  cy.getBySel(\"signup-last-name\").type(userInfo.lastName)\n  cy.getBySel(\"signup-username\").type(userInfo.username)\n  cy.getBySel(\"signup-password\").type(userInfo.password)\n  cy.getBySel(\"signup-confirmPassword\").type(userInfo.password)\n  cy.visualSnapshot(\"About to Sign Up\")\n  cy.getBySel(\"signup-submit\").click()\n  cy.wait(\"@signup\")\n\n  // Login User\n  cy.login(userInfo.username, userInfo.password)\n\n  // Onboarding\n  cy.getBySel(\"user-onboarding-dialog\").should(\"be.visible\")\n  cy.getBySel(\"list-skeleton\").should(\"not.exist\")\n  cy.getBySel(\"nav-top-notifications-count\").should(\"exist\")\n  cy.visualSnapshot(\"User Onboarding Dialog\")\n  cy.getBySel(\"user-onboarding-next\").click()\n\n  cy.getBySel(\"user-onboarding-dialog-title\").should(\n    \"contain\",\n    \"Create Bank Account\"\n  )\n\n  cy.getBySelLike(\"bankName-input\").type(\"The Best Bank\")\n  cy.getBySelLike(\"accountNumber-input\").type(\"123456789\")\n  cy.getBySelLike(\"routingNumber-input\").type(\"987654321\")\n  cy.visualSnapshot(\"About to complete User Onboarding\")\n  cy.getBySelLike(\"submit\").click()\n\n  cy.wait(\"@gqlCreateBankAccountMutation\")\n\n  cy.getBySel(\"user-onboarding-dialog-title\").should(\"contain\", \"Finished\")\n  cy.getBySel(\"user-onboarding-dialog-content\").should(\n    \"contain\",\n    \"You're all set!\"\n  )\n  cy.visualSnapshot(\"Finished User Onboarding\")\n  cy.getBySel(\"user-onboarding-next\").click()\n\n  cy.getBySel(\"transaction-list\").should(\"be.visible\")\n  cy.visualSnapshot(\"Transaction List is visible after User Onboarding\")\n\n  // Logout User\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click()\n  }\n  cy.getBySel(\"sidenav-signout\").click()\n  cy.location(\"pathname\").should(\"eq\", \"/signin\")\n  cy.visualSnapshot(\"Redirect to SignIn\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst we navigate to the application root route, which will redirect us to the sign in page.\n\nBy doing this, we are also confirming that our redirects are working as well.\n\n```js\ncy.visit(\"/\")\n```\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-06-28_at_2.19.09_PM.png)\n\nNext, we click on the \"Sign Up\" link\n\n```js\ncy.getBySel(\"signup\").click()\n```\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-06-28_at_2.20.07_PM.png)\n\nWe then assert that the sign-up title is visible and contains \"Sign Up.\"\n\nThis will ensure that we are correctly routed to the sign-up page after clicking on the sign-up link.\n\n```js\ncy.getBySel(\"signup-title\").should(\"be.visible\").and(\"contain\", \"Sign Up\")\n```\n\n## Sign Up Form\n\nNext, we declare a `userInfo` object since we will be using this data across multiple forms and expectations. Then, we fill out the sign-up form.\n\n```js\nconst userInfo = {\n  firstName: \"Bob\",\n  lastName: \"Ross\",\n  username: \"PainterJoy90\",\n  password: \"s3cret\",\n}\n\n// ...\n\ncy.getBySel(\"signup-first-name\").type(userInfo.firstName)\ncy.getBySel(\"signup-last-name\").type(userInfo.lastName)\ncy.getBySel(\"signup-username\").type(userInfo.username)\ncy.getBySel(\"signup-password\").type(userInfo.password)\ncy.getBySel(\"signup-confirmPassword\").type(userInfo.password)\n```\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-06-28_at_2.21.41_PM.png)\n\nFinally we click the Sign Up button to create our new user account.\n\n```js\ncy.getBySel(\"signup-submit\").click()\n```\n\nWe will use <apiLink apiName=\"wait\" displayName=\"cy.wait()\" /> to wait on our intercept which we aliased to `@signup` in the `beforeEach()` hook, to ensure the\n\n```js\ncy.wait(\"@signup\")\n```\n\n## Login\n\nAfter creating our user with the sign-in form, we then use `cy.login()` to log in as our new user.\n\n```js\nconst userInfo = {\n  firstName: \"Bob\",\n  lastName: \"Ross\",\n  username: \"PainterJoy90\",\n  password: \"s3cret\",\n}\n\n// ..\n\ncy.login(userInfo.username, userInfo.password)\n```\n\n## Onboarding\n\nAfter logging in, we see a multi-step form that walks the user through creating a bank account as part of the user's onboarding experience.\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-09-14_at_9.30.15_AM.png)\n\nFirst, we confirm that the onboarding modal is visible and that the loading skeleton is not.\n\n```js\ncy.getBySel(\"user-onboarding-dialog\").should(\"be.visible\")\ncy.getBySel(\"list-skeleton\").should(\"not.exist\")\n```\n\nWe also confirm that the notification icon exists and then click on the next button.\n\n```js\ncy.getBySel(\"nav-top-notifications-count\").should(\"exist\")\ncy.getBySel(\"user-onboarding-next\").click()\n```\n\nOn the next screen, we confirm that the modal contains the correct text.\n\n```js\ncy.getBySel(\"user-onboarding-dialog-title\").should(\n  \"contain\",\n  \"Create Bank Account\"\n)\n```\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-09-14_at_9.31.30_AM.png)\n\nWe then fill out the bank account creation form and submit.\n\n```js\ncy.getBySelLike(\"bankName-input\").type(\"The Best Bank\")\ncy.getBySelLike(\"accountNumber-input\").type(\"123456789\")\ncy.getBySelLike(\"routingNumber-input\").type(\"987654321\")\ncy.visualSnapshot(\"About to complete User Onboarding\")\ncy.getBySelLike(\"submit\").click()\n```\n\nWe then wait on our `@gqlCreateBankAccountMutation` alias to make sure the new bank account has been created before proceeding to the rest of the test.\n\n```js\ncy.wait(\"@gqlCreateBankAccountMutation\")\n```\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-09-14_at_9.32.01_AM.png)\n\nWe then confirm we are on the final screen of the onboarding process and click the next button to close the modal.\n\n```js\ncy.getBySel(\"user-onboarding-dialog-title\").should(\"contain\", \"Finished\")\ncy.getBySel(\"user-onboarding-dialog-content\").should(\n  \"contain\",\n  \"You're all set!\"\n)\ncy.getBySel(\"user-onboarding-next\").click()\n```\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-09-14_at_9.32.22_AM.png)\n\nWe then assert that the transaction view is visible, indicating that the onboarding modal has been closed.\n\n```js\ncy.getBySel(\"transaction-list\").should(\"be.visible\")\n```\n\n## Logout\n\nNow the only thing left to test is to make sure our users can log out. Once they do, we will also write an assertion to ensure they are redirected to the /signin page.\n\n![](/images/real-world-examples/authentication/sign-up-login-create-bank-account-and-logout/Screen_Shot_2021-06-28_at_2.36.27_PM.png)\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\ncy.getBySel(\"sidenav-signout\").click()\ncy.location(\"pathname\").should(\"eq\", \"/signin\")\n```\n\nThe `isMobile()` is a custom utility function we have written to determine if the viewport is a mobile device or not. You can find out more about how this works [here](/real-world-examples/custom-cypress-commands).\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Sign Up Login Create Bank Account And Logout"},"url":"/real-world-examples/sign-up-login-create-bank-account-and-logout","type":"lvl1"},{"title":"Unauthenticated Users","content":"# Unauthenticated Users\n\nBefore continuing, make sure you have read the [Authentication Overview & Setup](/real-world-examples/authentication-overview-and-setup) lesson first.\n\n```js\nit(\"should redirect unauthenticated user to signin page\", function () {\n  cy.visit(\"/personal\")\n  cy.location(\"pathname\").should(\"equal\", \"/signin\")\n})\n```\n\nFirst, we attempt to <apiLink apiName=\"visit\" displayName=\"cy.visit()\" /> the URL **/personal**, a protected route that only logged-in users can access.\n\n```js\ncy.visit(\"/personal\")\n```\n\nFinally, we assert that the application redirects users who are not logged in back to the **/signin** page.\n\n```js\ncy.location(\"pathname\").should(\"equal\", \"/signin\")\n```\n\n![](/images/real-world-examples/authentication/unauthenticated-users/Screen_Shot_2021-06-28_at_1.35.44_PM.png)\n\nThis is a straightforward test, but it is testing some critical functionality, as we do not want unauthorized users to gain access to our application. Now we can be confident that any unauthorized users will be automatically redirected to the Sign-in page.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Unauthenticated Users"},"url":"/real-world-examples/unauthenticated-users","type":"lvl1"},{"title":"Bank Accounts Overview And Setup","content":"# Bank Accounts Overview & Setup\n\nIn this section, we will be discussing the various tests located within the **cypress/tests/ui/bankaccounts.spec.ts** file.\n\nLet's break down what is happening within the `beforeEach()` as it is essential to understand what is going on since this hook is running before each test.\n\n## beforeEach()\n\n```js\nbeforeEach(function () {\n  cy.task(\"db:seed\")\n\n  cy.intercept(\"GET\", \"/notifications\").as(\"getNotifications\")\n\n  cy.intercept(\"POST\", apiGraphQL, (req) => {\n    const { body } = req\n\n    if (\n      body.hasOwnProperty(\"operationName\") &&\n      body.operationName === \"ListBankAccount\"\n    ) {\n      req.alias = \"gqlListBankAccountQuery\"\n    }\n\n    if (\n      body.hasOwnProperty(\"operationName\") &&\n      body.operationName === \"CreateBankAccount\"\n    ) {\n      req.alias = \"gqlCreateBankAccountMutation\"\n    }\n\n    if (\n      body.hasOwnProperty(\"operationName\") &&\n      body.operationName === \"DeleteBankAccount\"\n    ) {\n      req.alias = \"gqlDeleteBankAccountMutation\"\n    }\n  })\n\n  cy.database(\"find\", \"users\").then((user: User) => {\n    ctx.user = user\n\n    return cy.loginByXstate(ctx.user.username)\n  })\n})\n```\n\nYou can find out more information about the custom Cypress commands used [here](/real-world-examples/custom-cypress-commands).\n\nThe first thing we are doing is seeding our database using a custom Cypress task.\n\n```js\ncy.task(\"db:seed\")\n```\n\nNext, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept every **GET** request to the **/notifications** route. We are then aliasing this intercept to \"getNotifications.\" When you see `@getNotifications` used within a test, it is referring to this intercept.\n\n```js\ncy.intercept(\"GET\", \"/notifications\").as(\"getNotifications\")\n```\n\nNext, we have another <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept every **POST** request to our GraphQL endpoint. We then have three conditionals to determine the GraphQL query and then set the appropriate alias accordingly.\n\n```js\ncy.intercept(\"POST\", apiGraphQL, (req) => {\n  const { body } = req\n\n  if (\n    body.hasOwnProperty(\"operationName\") &&\n    body.operationName === \"ListBankAccount\"\n  ) {\n    req.alias = \"gqlListBankAccountQuery\"\n  }\n\n  if (\n    body.hasOwnProperty(\"operationName\") &&\n    body.operationName === \"CreateBankAccount\"\n  ) {\n    req.alias = \"gqlCreateBankAccountMutation\"\n  }\n\n  if (\n    body.hasOwnProperty(\"operationName\") &&\n    body.operationName === \"DeleteBankAccount\"\n  ) {\n    req.alias = \"gqlDeleteBankAccountMutation\"\n  }\n})\n```\n\nFinally, we use a custom Cypress command `cy.database()` to query our database for our users. Then we use another custom Cypress command `cy.loginByXstate()` to log in to the application using one of the users returned from the `cy.database()`.\n\nYou can find out how these custom Commands work in greater detail [here](/real-world-examples/custom-cypress-commands).\n\n```js\ncy.database(\"find\", \"users\").then((user: User) => {\n  cy.loginByXstate(user.username)\n})\n```\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Bank Accounts Overview And Setup"},"url":"/real-world-examples/bank-accounts-overview-and-setup","type":"lvl1"},{"title":"Creating A New Bank Account","content":"# Creating a New Bank Account\n\nBefore continuing, make sure you have read the [Bank Accounts Overview & Setup](/real-world-examples/bank-accounts-overview-and-setup) lesson first.\n\n```js\nit(\"creates a new bank account\", function () {\n  cy.wait(\"@getNotifications\")\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click()\n  }\n\n  cy.getBySel(\"sidenav-bankaccounts\").click()\n\n  cy.getBySel(\"bankaccount-new\").click()\n  cy.location(\"pathname\").should(\"eq\", \"/bankaccounts/new\")\n  cy.visualSnapshot(\"Display New Bank Account Form\")\n\n  cy.getBySelLike(\"bankName-input\").type(\"The Best Bank\")\n  cy.getBySelLike(\"routingNumber-input\").type(\"987654321\")\n  cy.getBySelLike(\"accountNumber-input\").type(\"123456789\")\n  cy.visualSnapshot(\"Fill out New Bank Account Form\")\n  cy.getBySelLike(\"submit\").click()\n\n  cy.wait(\"@gqlCreateBankAccountMutation\")\n\n  cy.getBySelLike(\"bankaccount-list-item\")\n    .should(\"have.length\", 2)\n    .eq(1)\n    .should(\"contain\", \"The Best Bank\")\n  cy.visualSnapshot(\"Bank Account Created\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we wait upon our aliased intercept `@getNotifications`\n\n```js\ncy.wait(\"@getNotifications\")\n```\n\nNext, we click on the \"Bank Accounts\" link in the left sidebar, depending upon if we are a mobile device or not. You can find out more info about the `isMobile()` utility function [here](/real-world-examples/custom-cypress-commands).\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\n\ncy.getBySel(\"sidenav-bankaccounts\").click()\n```\n\n![](/images/real-world-examples/bank-accounts/creating-a-new-bank-account/Screen_Shot_2021-06-30_at_10.19.19_AM.png)\n\nNext, we will click on the \"Create\" button and write an assertion that the application has taken us to the correct screen by validating the URL.\n\n```js\ncy.getBySel(\"bankaccount-new\").click()\ncy.location(\"pathname\").should(\"eq\", \"/bankaccounts/new\")\n```\n\n![](/images/real-world-examples/bank-accounts/creating-a-new-bank-account/Screen_Shot_2021-06-30_at_10.21.15_AM.png)\n\nThen, we fill out the new bank account form with our bank account information and save it.\n\n```js\n// Create Bank Account Form\ncy.getBySelLike(\"bankName-input\").type(\"The Best Bank\")\ncy.getBySelLike(\"routingNumber-input\").type(\"987654321\")\ncy.getBySelLike(\"accountNumber-input\").type(\"123456789\")\ncy.getBySelLike(\"submit\").click()\n```\n\n![](/images/real-world-examples/bank-accounts/creating-a-new-bank-account/Screen_Shot_2021-06-30_at_10.22.29_AM.png)\n\nWe then wait for our GraphQL mutation to create a new bank account.\n\n```js\ncy.wait(\"@gqlCreateBankAccountMutation\")\n```\n\nFinally, we will write an assertion that ensures that our new bank account is created successfully.\n\n```js\ncy.getBySelLike(\"bankaccount-list-item\")\n  .should(\"have.length\", 2)\n  .eq(1)\n  .should(\"contain\", \"The Best Bank\")\n```\n\n![](/images/real-world-examples/bank-accounts/creating-a-new-bank-account/Screen_Shot_2021-06-30_at_10.25.36_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Creating A New Bank Account"},"url":"/real-world-examples/creating-a-new-bank-account","type":"lvl1"},{"title":"Users Without Bank Accounts","content":"# Users without Bank Accounts\n\nBefore continuing, make sure you have read the [Bank Accounts Overview & Setup](/real-world-examples/bank-accounts-overview-and-setup) lesson first.\n\n```js\nit(\"renders an empty bank account list state with onboarding modal\", function () {\n  cy.wait(\"@getNotifications\")\n  cy.intercept(\"POST\", apiGraphQL, (req) => {\n    const { body } = req\n    if (\n      body.hasOwnProperty(\"operationName\") &&\n      body.operationName === \"ListBankAccount\"\n    ) {\n      req.alias = \"gqlListBankAccountQuery\"\n      req.continue((res) => {\n        res.body.data.listBankAccount = []\n      })\n    }\n  })\n\n  cy.visit(\"/bankaccounts\")\n  cy.wait(\"@getNotifications\")\n  cy.wait(\"@gqlListBankAccountQuery\")\n\n  cy.getBySel(\"bankaccount-list\").should(\"not.exist\")\n  cy.getBySel(\"empty-list-header\").should(\"contain\", \"No Bank Accounts\")\n  cy.getBySel(\"user-onboarding-dialog\").should(\"be.visible\")\n  cy.getBySel(\"nav-top-notifications-count\").should(\"exist\")\n  cy.visualSnapshot(\"User Onboarding Dialog is Visible\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we wait upon our aliased intercept `@getNotifications`\n\n```js\ncy.wait(\"@getNotifications\")\n```\n\nNext, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept the **POST** request to our GraphQL endpoint. We then determine if the **POST** request is a GraphQL query to \"ListBankAccount.\" If so, we set the alias to `gqlListBankAccountQuery`.\n\nThen we clear out any `listBankAccount` items that come back by setting this property on the response to an empty array. This is how we manipulate the response data to ensure we \"render an empty bank account list,\" which is necessary for our test.\n\n```js\ncy.intercept(\"POST\", `${Cypress.env(\"apiUrl\")}/graphql`, (req) => {\n  const { body } = req\n  if (\n    body.hasOwnProperty(\"operationName\") &&\n    body.operationName === \"ListBankAccount\"\n  ) {\n    req.alias = \"gqlListBankAccountQuery\"\n    req.continue((res) => {\n      res.body.data.listBankAccount = []\n    })\n  }\n})\n```\n\nWe then <apiLink apiName=\"visit\" displayName=\"cy.visit()\" /> the **/bankaccounts** route.\n\n```js\ncy.visit(\"/bankaccounts\")\n```\n\nThen we wait on two intercepts—one for `@getNotifications` and the other for `@gqlListBankAccountQuery`. Remember the `@getNotifications` intercept happens in the `beforeEach()` hook.\n\n```js\ncy.wait(\"@getNotifications\")\ncy.wait(\"@gqlListBankAccountQuery\")\n```\n\nFinally, we write some assertions to make sure our UI is displaying the elements that it should. We first want to ensure that the element that would normally display our bank accounts does not exist in the DOM.\n\nThen, we make sure we are displaying the correct message since there are no bank accounts.\n\nNext, we assert that the onboarding modal window is visible.\n\nFinally, we assert that the user's notification count is visible.\n\n```js\ncy.getBySel(\"bankaccount-list\").should(\"not.exist\")\ncy.getBySel(\"empty-list-header\").should(\"contain\", \"No Bank Accounts\")\ncy.getBySel(\"user-onboarding-dialog\").should(\"be.visible\")\ncy.getBySel(\"nav-top-notifications-count\").should(\"exist\")\n```\n\n![](/images/real-world-examples/bank-accounts/users-without-bank-accounts/Screen_Shot_2021-06-30_at_1.17.05_PM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Users Without Bank Accounts"},"url":"/real-world-examples/users-without-bank-accounts","type":"lvl1"},{"title":"New Transaction Overview And Setup","content":"# New Transaction Overview & Setup\n\nIn this section, we will be discussing the various tests located within the **cypress/tests/ui/new-transaction.spec.ts** file.\n\nLet's breakdown what is happening within the `beforeEach()` as it is important to understand what is going on since this hook is running before each test.\n\n## beforeEach()\n\n```js\ndescribe(\"New Transaction\", function () {\n  const ctx: NewTransactionTestCtx = {};\n\n  beforeEach(function () {\n    cy.task(\"db:seed\");\n\n    cy.intercept(\"GET\", \"/users*\").as(\"allUsers\");\n\n    cy.intercept(\"GET\", \"/users/search*\").as(\"usersSearch\");\n\n    cy.intercept(\"POST\", \"/transactions\").as(\"createTransaction\");\n\n    cy.intercept(\"GET\", \"/notifications\").as(\"notifications\");\n    cy.intercept(\"GET\", \"/transactions/public\").as(\"publicTransactions\");\n    cy.intercept(\"GET\", \"/transactions\").as(\"personalTransactions\");\n    cy.intercept(\"PATCH\", \"/transactions/*\").as(\"updateTransaction\");\n\n    cy.database(\"filter\", \"users\").then((users: User[]) => {\n      ctx.allUsers = users;\n      ctx.user = users[0];\n      ctx.contact = users[1];\n\n      return cy.loginByXstate(ctx.user.username);\n    });\n  });\n```\n\nYou can find out more information about the custom Cypress commands used [here](/real-world-examples/custom-cypress-commands).\n\nThe first thing we are doing is seeding our database using a custom Cypress task.\n\n```js\ncy.task(\"db:seed\")\n```\n\nNext, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept and alias several requests.\n\n```js\ncy.intercept(\"GET\", \"/users*\").as(\"allUsers\")\ncy.intercept(\"GET\", \"/users/search*\").as(\"usersSearch\")\ncy.intercept(\"POST\", \"/transactions\").as(\"createTransaction\")\ncy.intercept(\"GET\", \"/notifications\").as(\"notifications\")\ncy.intercept(\"GET\", \"/transactions/public\").as(\"publicTransactions\")\ncy.intercept(\"GET\", \"/transactions\").as(\"personalTransactions\")\ncy.intercept(\"PATCH\", \"/transactions/*\").as(\"updateTransaction\")\n```\n\nNext, we are using a custom Cypress command `cy.database()` to get some users from the database. We then store some of this information in the `ctx` object. Lastly, we log in as one of the users returned from the `cy.database()` command.\n\n```js\nconst ctx: NewTransactionTestCtx = {}\n// ...\n\ncy.database(\"filter\", \"users\").then((users: User[]) => {\n  ctx.allUsers = users\n  ctx.user = users[0]\n  ctx.contact = users[1]\n\n  return cy.loginByXstate(ctx.user.username)\n})\n```\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"New Transaction Overview And Setup"},"url":"/real-world-examples/new-transaction-overview-and-setup","type":"lvl1"},{"title":"Searching By Attributes","content":"# Searching by attributes\n\nBefore continuing, make sure you have read the [New Transaction Overview & Setup](/real-world-examples/new-transaction-overview-and-setup) lesson first.\n\n```js\ncontext(\"searches for a user by attribute\", function () {\n    const searchAttrs: (keyof User)[] = [\n      \"firstName\",\n      \"lastName\",\n      \"username\",\n      \"email\",\n      \"phoneNumber\",\n    ];\n\n    beforeEach(function () {\n      cy.getBySelLike(\"new-transaction\").click();\n      cy.wait(\"@allUsers\");\n    });\n\n    searchAttrs.forEach((attr: keyof User) => {\n      it(attr, function () {\n        const targetUser = ctx.allUsers![2];\n\n        cy.log(`Searching by **${attr}**`);\n        cy.getBySel(\"user-list-search-input\").type(targetUser[attr] as string, { force: true });\n        cy.wait(\"@usersSearch\")\n          // make sure the backend returns some results\n          .its(\"response.body.results\")\n          .should(\"have.length.gt\", 0)\n          .its(\"length\")\n          .then((resultsN) => {\n            cy.getBySelLike(\"user-list-item\")\n              // make sure the list of results is fully updated\n              // and shows the number of results returned from the backend\n              .should(\"have.length\", resultsN)\n              .first()\n              .contains(targetUser[attr] as string);\n          });\n\n        cy.visualSnapshot(`User List for Search: ${attr} = ${targetUser[attr]}`);\n\n        cy.focused().clear();\n        cy.getBySel(\"users-list\").should(\"be.empty\");\n        cy.visualSnapshot(\"User List Clear Search\");\n      });\n    });\n  });\n\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we create a `searchAttrs` array that contains all of the user attributes we intend to search for.\n\n```js\nconst searchAttrs: (keyof User)[] = [\n      \"firstName\",\n      \"lastName\",\n      \"username\",\n      \"email\",\n      \"phoneNumber\",\n    ];\n\n```\n\nNext we have a `beforeEach()` hook that clicks on the \"New\" transaction button and waits for our `@allUsers` intercept. Remember, this intercept occurs in the `beforeEach()` hook at the top of this spec file.\n\n```js\nbeforeEach(function () {\n  cy.getBySelLike(\"new-transaction\").click()\n  cy.wait(\"@allUsers\")\n})\n```\n\n![](/images/real-world-examples/new-transactions/searching-by-attributes/Screen_Shot_2021-09-16_at_8.59.28_AM.png)\n\nThen, we are looping through the `searchAttrs` array to dynamically create our tests, one for each attribute in the array. Remember that Cypress is just JavaScript, which allows us to dynamically generate our tests instead of manually creating a test for each attribute.\n\n```js\nsearchAttrs.forEach((attr: keyof User) => {\n      it(attr, function () {\n        const targetUser = ctx.allUsers![2];\n\n        cy.log(`Searching by **${attr}**`);\n        cy.getBySel(\"user-list-search-input\").type(targetUser[attr] as string, { force: true });\n        cy.wait(\"@usersSearch\")\n          // make sure the backend returns some results\n          .its(\"response.body.results\")\n          .should(\"have.length.gt\", 0)\n          .its(\"length\")\n          .then((resultsN) => {\n            cy.getBySelLike(\"user-list-item\")\n              // make sure the list of results is fully updated\n              // and shows the number of results returned from the backend\n              .should(\"have.length\", resultsN)\n              .first()\n              .contains(targetUser[attr] as string);\n          });\n\n        cy.visualSnapshot(`User List for Search: ${attr} = ${targetUser[attr]}`);\n\n        cy.focused().clear();\n        cy.getBySel(\"users-list\").should(\"be.empty\");\n        cy.visualSnapshot(\"User List Clear Search\");\n      });\n    });\n\n```\n\nWithin our `.forEach()`, you can see that the first thing we do is create our `.it()` test and pass in the attribute as the test name.\n\n```js\nit(attr, function () {\n\n// ...\n\n```\n\nNext, we grab a user from our `ctx` object created in the `.beforeEach()` at the top of this spec file.\n\n```js\nconst targetUser = ctx.allUsers![2];\n\n```\n\nWe then use <apiLink apiName=\"log\" displayName=\"cy.log()\" /> to output a custom message to the Cypress Command Log in the test runner. This makes it easy for us to see what is happening in the test runner and is helpful for debugging.\n\n```js\ncy.log(`Searching by **${attr}**`)\n```\n\n![](/images/real-world-examples/new-transactions/searching-by-attributes/Screen_Shot_2021-09-16_at_9.01.48_AM.png)\n\nWe then perform a search for the specific attribute.\n\n```js\ncy.getBySel(\"user-list-search-input\").type(targetUser[attr] as string, { force: true });\n\n```\n\n![](/images/real-world-examples/new-transactions/searching-by-attributes/Screen_Shot_2021-09-16_at_9.02.29_AM.png)\n\nNext, we wait upon the `@usersSearch` intercept, which occurs in the `.beforeEach()` at the top of the spec file.\n\n```js\ncy.wait(\"@usersSearch\")\n```\n\nWe then grab the `results` from the `response.body` and write an assertion to make sure we have some results, i.e the `results` array should not be empty\n\n```js\n.its(\"response.body.results\")\n.should(\"have.length.gt\", 0)\n\n```\n\n![](/images/real-world-examples/new-transactions/searching-by-attributes/Screen_Shot_2021-09-16_at_9.03.24_AM.png)\n\nThen, we get the `.length` of the `results` array and write an assertion to make sure our UI displays the correct number of results returned from our back-end. We also have an assertion that the first item displayed in the search is the attribute we searched for.\n\n```js\n.its(\"length\")\n          .then((resultsN) => {\n            cy.getBySelLike(\"user-list-item\")\n              // make sure the list of results is fully updated\n              // and shows the number of results returned from the backend\n              .should(\"have.length\", resultsN)\n              .first()\n              .contains(targetUser[attr] as string);\n\n```\n\n![](/images/real-world-examples/new-transactions/searching-by-attributes/Screen_Shot_2021-09-16_at_9.03.54_AM.png)\n\nFinally, we make sure that the users list is empty.\n\n```js\ncy.focused().clear()\ncy.getBySel(\"users-list\").should(\"be.empty\")\n```\n\n![](/images/real-world-examples/new-transactions/searching-by-attributes/Screen_Shot_2021-09-16_at_9.04.28_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Searching By Attributes"},"url":"/real-world-examples/searching-by-attributes","type":"lvl1"},{"title":"Submitting A Payment To Another User","content":"# Submitting a payment to another user\n\nBefore continuing, make sure you have read the [New Transaction Overview & Setup](/real-world-examples/new-transaction-overview-and-setup) lesson first.\n\n```js\nit(\"navigates to the new transaction form, selects a user and submits a transaction payment\", function () {\n    const payment = {\n      amount: \"35\",\n      description: \"Sushi dinner 🍣\",\n    };\n\n    cy.getBySelLike(\"new-transaction\").click();\n    cy.wait(\"@allUsers\");\n\n    cy.getBySel(\"user-list-search-input\").type(ctx.contact!.firstName, { force: true });\n    cy.wait(\"@usersSearch\");\n    cy.visualSnapshot(\"User Search First Name Input\");\n\n    cy.getBySelLike(\"user-list-item\").contains(ctx.contact!.firstName).click({ force: true });\n    cy.visualSnapshot(\"User Search First Name List Item\");\n\n    cy.getBySelLike(\"amount-input\").type(payment.amount);\n    cy.getBySelLike(\"description-input\").type(payment.description);\n    cy.visualSnapshot(\"Amount and Description Input\");\n    cy.getBySelLike(\"submit-payment\").click();\n    cy.wait([\"@createTransaction\", \"@getUserProfile\"]);\n    cy.getBySel(\"alert-bar-success\")\n      .should(\"be.visible\")\n      .and(\"have.text\", \"Transaction Submitted!\");\n\n    const updatedAccountBalance = Dinero({\n      amount: ctx.user!.balance - parseInt(payment.amount) * 100,\n    }).toFormat();\n\n    if (isMobile()) {\n      cy.getBySel(\"sidenav-toggle\").click();\n    }\n\n    cy.getBySelLike(\"user-balance\").should(\"contain\", updatedAccountBalance);\n    cy.visualSnapshot(\"Updated User Balance\");\n\n    if (isMobile()) {\n      cy.get(\".MuiBackdrop-root\").click({ force: true });\n    }\n\n    cy.getBySelLike(\"create-another-transaction\").click();\n    cy.getBySel(\"app-name-logo\").find(\"a\").click();\n    cy.getBySelLike(\"personal-tab\").click().should(\"have.class\", \"Mui-selected\");\n    cy.wait(\"@personalTransactions\");\n\n    cy.getBySel(\"transaction-list\").first().should(\"contain\", payment.description);\n\n    cy.database(\"find\", \"users\", { id: ctx.contact!.id })\n      .its(\"balance\")\n      .should(\"equal\", ctx.contact!.balance + parseInt(payment.amount) * 100);\n    cy.getBySel(\"alert-bar-success\").should(\"not.exist\");\n    cy.visualSnapshot(\"Personal List Validate Transaction in List\");\n  });\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we create a simple `payment` object.\n\n```js\nconst payment = {\n  amount: \"35\",\n  description: \"Sushi dinner 🍣\",\n}\n```\n\nNext, we click on the \"New\" transaction button.\n\n```js\ncy.getBySelLike(\"new-transaction\").click()\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_3.56.39_PM.png)\n\nWe then on our aliased intercept `@allUsers`. Remember, this happens in the `beforeEach()` hook before this test is run.\n\n```js\ncy.wait(\"@allUsers\")\n```\n\nThen we search for a user and wait on the `@usersSearch` intercept.\n\n```js\ncy.getBySel(\"user-list-search-input\").type(ctx.contact!.firstName, { force: true });\n    cy.wait(\"@usersSearch\");\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.01.10_PM.png)\n\nWe then make an assertion that the user that we just searched for appears in the search results and then we click on that user to make a payment to them.\n\n```js\ncy.getBySelLike(\"user-list-item\").contains(ctx.contact!.firstName).click({ force: true });\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.02.44_PM.png)\n\nOn the payment screen we enter the payment amount and description and submit the payment.\n\n```js\ncy.getBySelLike(\"amount-input\").type(payment.amount)\ncy.getBySelLike(\"description-input\").type(payment.description)\ncy.getBySelLike(\"submit-payment\").click()\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.04.08_PM.png)\n\nWe then wait upon two intercepts `@createTransaction` and `@getUserProfile` . Notice how you can wait upon multiple intercepts by putting them into an array.\n\nThen we assert that the transaction was submitted successfully.\n\n```js\ncy.wait([\"@createTransaction\", \"@getUserProfile\"])\ncy.getBySel(\"alert-bar-success\")\n  .should(\"be.visible\")\n  .and(\"have.text\", \"Transaction Submitted!\")\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.07.10_PM.png)\n\nNext, we create a constant called `updatedAccountBalance`\n\n```js\nconst updatedAccountBalance = Dinero({\n      amount: ctx.user!.balance - parseInt(payment.amount) * 100,\n    }).toFormat();\n```\n\nWe are using a 3rd party library called [Dinero.js](https://dinerojs.com/) which handles currency formatting. Since Cypress is just JavaScript, we can import this library and use it within our test.\n\nThen we use our `isMobile()` utility function to determine if our test is being run in a mobile viewport. If so, we click on the button to toggle the sidebar.\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\n```\n\nWe then make an assertion that the user's account balance has been updated to the correct amount via the payment we just made.\n\n```js\ncy.getBySelLike(\"user-balance\").should(\"contain\", updatedAccountBalance)\n```\n\nNext, we click on the \"Create another Transaction\" button, then the app name logo in the header and write an assertion to make sure one of the tabs in the app has the correct class.\n\n```js\ncy.getBySelLike(\"create-another-transaction\").click()\ncy.getBySel(\"app-name-logo\").find(\"a\").click()\ncy.getBySelLike(\"personal-tab\").click().should(\"have.class\", \"Mui-selected\")\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.14.03_PM.png)\n\nNext, we wait upon the `@personalTransactions` intercept.\n\n```js\ncy.wait(\"@personalTransactions\")\n```\n\nThen we write an assertion to ensure that the first transaction in the list contains the correct description from the transaction we just made.\n\n```js\ncy.getBySel(\"transaction-list\").first().should(\"contain\", payment.description)\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.16.18_PM.png)\n\nWe then use the custom Cypress command `cy.database()` to find the user we just made the payment to and assert that their balance in the database has been updated appropriately.\n\n```js\ncy.database(\"find\", \"users\", { id: ctx.contact!.id })\n      .its(\"balance\")\n      .should(\"equal\", ctx.contact!.balance + parseInt(payment.amount) * 100);\n```\n\n![](/images/real-world-examples/new-transactions/submitting-a-payment-to-another-user/Screen_Shot_2021-09-14_at_4.18.23_PM.png)\n\nFinally, we assert that the alert bar does not exist in the DOM.\n\n```js\ncy.getBySel(\"alert-bar-success\").should(\"not.exist\")\n```\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Submitting A Payment To Another User"},"url":"/real-world-examples/submitting-a-payment-to-another-user","type":"lvl1"},{"title":"Verifying The Deposit Of A Payment","content":"# Verifying the deposit of a payment\n\nBefore continuing, make sure you have read the [New Transaction Overview & Setup](/real-world-examples/new-transaction-overview-and-setup) lesson first.\n\n```js\nit(\"submits a transaction payment and verifies the deposit for the receiver\", function () {\n  cy.getBySel(\"nav-top-new-transaction\").click();\n\n  const transactionPayload = {\n    transactionType: \"payment\",\n    amount: 25,\n    description: \"Indian Food\",\n    sender: ctx.user,\n    receiver: ctx.contact,\n  };\n\n  // first let's grab the current balance from the UI\n  let startBalance: string;\n  if (!isMobile()) {\n    // only check the balance display in desktop resolution\n    // as it is NOT shown on mobile screen\n    cy.get(\"[data-test=sidenav-user-balance]\")\n      .invoke(\"text\")\n      .then((x) => {\n        startBalance = x; // something like \"$1,484.81\"\n        expect(startBalance).to.match(/\\$\\d/);\n      });\n  }\n\n  cy.createTransaction(transactionPayload);\n  cy.wait(\"@createTransaction\");\n  cy.getBySel(\"new-transaction-create-another-transaction\").should(\"be.visible\");\n\n  if (!isMobile()) {\n    // make sure the new balance is displayed\n    cy.get(\"[data-test=sidenav-user-balance]\").should(($el) => {\n      // here we only make sure the text has changed\n      // we could also convert the balance to actual number\n      // and confirm the new balance is the start balance - amount\n      expect($el.text()).to.not.equal(startBalance);\n    });\n  }\n  cy.visualSnapshot(\"Transaction Payment Submitted Notification\");\n\n  cy.switchUserByXstate(ctx.contact!.username);\n\n  const updatedAccountBalance = Dinero({\n    amount: ctx.contact!.balance + transactionPayload.amount * 100,\n  }).toFormat();\n\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click();\n  }\n\n  cy.getBySelLike(\"user-balance\").should(\"contain\", updatedAccountBalance);\n  cy.visualSnapshot(\"Verify Updated Sender Account Balance\");\n});\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we click on the \"New\" transaction button.\n\n```js\ncy.getBySel(\"nav-top-new-transaction\").click()\n```\n\n![](/images/real-world-examples/new-transactions/verifying-the-deposit-of-a-payment/Screen_Shot_2021-09-14_at_4.23.04_PM.png)\n\nWe then create a `transactionPayload` object.\n\n```js\nconst transactionPayload = {\n  transactionType: \"payment\",\n  amount: 25,\n  description: \"Indian Food\",\n  sender: ctx.user,\n  receiver: ctx.contact,\n}\n```\n\nThen, we grab the current balance from the UI, only if we are _not_ in a mobile viewport and store it inside of the `starteBalance` variable.\n\n```js\n// first let's grab the current balance from the UI\nlet startBalance: string\nif (!isMobile()) {\n  // only check the balance display in desktop resolution\n  // as it is NOT shown on mobile screen\n  cy.get(\"[data-test=sidenav-user-balance]\")\n    .invoke(\"text\")\n    .then((x) => {\n      startBalance = x // something like \"$1,484.81\"\n      expect(startBalance).to.match(/\\$\\d/)\n    })\n}\n```\n\nWe then create a new transaction using a custom Cypress command `cy.createTransaction()` with the `transactionPayload` object we created earlier.\n\n```js\ncy.createTransaction(transactionPayload)\n```\n\nWe then wait on the `@createTransaction` intercept and assert the \"Create Another Transaction\" button is visible\n\n```js\ncy.wait(\"@createTransaction\")\ncy.getBySel(\"new-transaction-create-another-transaction\").should(\"be.visible\")\n```\n\n![](/images/real-world-examples/new-transactions/verifying-the-deposit-of-a-payment/Screen_Shot_2021-09-14_at_4.27.36_PM.png)\n\nWe then make sure we are not in a mobile viewport and assert that the user balance has been updated from the transaction we just created.\n\n```js\nif (!isMobile()) {\n  // make sure the new balance is displayed\n  cy.get(\"[data-test=sidenav-user-balance]\").should(($el) => {\n    // here we only make sure the text has changed\n    // we could also convert the balance to actual number\n    // and confirm the new balance is the start balance - amount\n    expect($el.text()).to.not.equal(startBalance)\n  })\n}\n```\n\nWe then switch users by using a custom command `cy.switchUserByXstate()`\n\n```js\ncy.switchUserByXstate(ctx.contact!.username);\n```\n\nWe then use a 3rd party library called [Dinero.js](https://dinerojs.com/) to format the `updatedAccountBalance` properly.\n\n```js\nconst updatedAccountBalance = Dinero({\n      amount: ctx.contact!.balance + transactionPayload.amount * 100,\n    }).toFormat();\n```\n\nIf we are in a mobile viewport we click the button to open the sidebar.\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\n```\n\nFinally, we assert that the user's balance contains the correct amount.\n\n```js\ncy.getBySelLike(\"user-balance\").should(\"contain\", updatedAccountBalance)\n```\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Verifying The Deposit Of A Payment"},"url":"/real-world-examples/verifying-the-deposit-of-a-payment","type":"lvl1"},{"title":"Notifications Between Several Users","content":"# Notifications between several users\n\nBefore continuing, make sure you have read the [Notifications Overview & Setup](/real-world-examples/notifications-overview-and-setup) lesson first.\n\n```js\nit(\"User C comments on a transaction between User A and User B; User A and B get notifications that User C commented on their transaction\", function () {\n  cy.loginByXstate(ctx.userC.username)\n\n  cy.database(\"find\", \"transactions\", {\n    senderId: ctx.userB.id,\n    receiverId: ctx.userA.id,\n  }).then((transaction: Transaction) => {\n    cy.visit(`/transaction/${transaction.id}`)\n  })\n\n  cy.getBySelLike(\"comment-input\").type(\"Thank You{enter}\")\n\n  cy.wait(\"@postComment\")\n\n  cy.switchUserByXstate(ctx.userA.username)\n  cy.visualSnapshot(\"Switch to User A\")\n  cy.visualSnapshot(`Switch to User ${ctx.userA.username}`)\n\n  cy.getBySelLike(\"notifications-link\").click()\n\n  cy.wait(\"@getNotifications\")\n\n  cy.getBySelLike(\"notification-list-item\")\n    .should(\"have.length\", 9)\n    .first()\n    .should(\"contain\", ctx.userC.firstName)\n    .and(\"contain\", \"commented\")\n  cy.visualSnapshot(\"User A Notified of User C Comment\")\n\n  cy.switchUserByXstate(ctx.userB.username)\n  cy.visualSnapshot(`Switch to User ${ctx.userB.username}`)\n\n  cy.getBySelLike(\"notifications-link\").click()\n  cy.getBySelLike(\"notification-list-item\")\n    .should(\"have.length\", 9)\n    .first()\n    .should(\"contain\", ctx.userC.firstName)\n    .and(\"contain\", \"commented\")\n  cy.visualSnapshot(\"User B Notified of User C Comment\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we log in as `userC` from the `ctx` object, which we set up in the `beforeEach()` hook at the top of this spec file.\n\n```js\ncy.loginByXstate(ctx.userC.username)\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.11.51_AM.png)\n\nNext, we us a custom Cypress command `cy.database()` to find transactions between `userB` and `userA`, which again come from the `ctx` object we setup in the `beforeEach()` hook at the top of this spec file. After we find a transaction, we visit that specific transaction page.\n\n```js\ncy.database(\"find\", \"transactions\", {\n  senderId: ctx.userB.id,\n  receiverId: ctx.userA.id,\n}).then((transaction: Transaction) => {\n  cy.visit(`/transaction/${transaction.id}`)\n})\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.12.20_AM.png)\n\nThen, we enter a comment on the transaction page and wait on the `@postComment` intercept. Remember, this intercept happens in the `beforeEach()` at the top of this spec file.\n\n```js\ncy.getBySelLike(\"comment-input\").type(\"Thank You{enter}\")\n\ncy.wait(\"@postComment\")\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.12.52_AM.png)\n\nNext, we switch users again, this time logging in a `userA`\n\n```js\ncy.switchUserByXstate(ctx.userA.username)\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.13.37_AM.png)\n\nNow that we are logged in as `userA` we click on the notifications button to view `userA`'s notifications. We also wait for the `@getNotifications` intercept. Remember, this intercept happens in the `beforeEach()` at the top of this spec file.\n\n```js\ncy.getBySelLike(\"notifications-link\").click()\n\ncy.wait(\"@getNotifications\")\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.14.39_AM.png)\n\nThen, we confirm our user has a total of **9** notifications and that the first notifications contains the first name of `userC` along with the text \"commented\"\n\n```js\ncy.getBySelLike(\"notification-list-item\")\n  .should(\"have.length\", 9)\n  .first()\n  .should(\"contain\", ctx.userC.firstName)\n  .and(\"contain\", \"commented\")\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.15.06_AM.png)\n\nWe switch users yet again, this time logging in as `userB`\n\n```js\ncy.switchUserByXstate(ctx.userB.username)\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.15.23_AM.png)\n\nWe then perform similar assertions like we just did for `userA`. We want to make sure that `userB` has a total of **9** notifications and that the first notifications contains the first name of `userC` along with the text \"commented\"\n\n```js\ncy.getBySelLike(\"notifications-link\").click()\ncy.getBySelLike(\"notification-list-item\")\n  .should(\"have.length\", 9)\n  .first()\n  .should(\"contain\", ctx.userC.firstName)\n  .and(\"contain\", \"commented\")\n```\n\n![](/images/real-world-examples/notifications/notifications-between-several-users/Screen_Shot_2021-09-16_at_9.15.41_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Notifications Between Several Users"},"url":"/real-world-examples/notifications-between-several-users","type":"lvl1"},{"title":"Notifications Overview And Setup","content":"# Notifications Overview & Setup\n\nIn this section, we will be discussing the various tests located within the **cypress/tests/ui/notifications.spec.ts** file.\n\nLet's break down what is happening within the `beforeEach()` as it is essential to understand what is going on since this hook is running before each test.\n\n## beforeEach()\n\n```js\nconst ctx = {} as NotificationsCtx;\n\n  beforeEach(function () {\n    cy.task(\"db:seed\");\n\n    cy.intercept(\"GET\", \"/notifications*\").as(\"getNotifications\");\n    cy.intercept(\"POST\", \"/transactions\").as(\"createTransaction\");\n    cy.intercept(\"PATCH\", \"/notifications/*\").as(\"updateNotification\");\n    cy.intercept(\"POST\", \"/comments/*\").as(\"postComment\");\n\n    cy.database(\"filter\", \"users\").then((users: User[]) => {\n      ctx.userA = users[0];\n      ctx.userB = users[1];\n      ctx.userC = users[2];\n    });\n  });\n\n```\n\nYou can find out more information about the custom Cypress commands used [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we are using a custom Cypress task to seed our database.\n\n```js\ncy.task(\"db:seed\")\n```\n\nThen, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept several requests and aliasing them to be used later on within our tests.\n\n```js\ncy.intercept(\"GET\", \"/notifications*\").as(\"getNotifications\")\ncy.intercept(\"POST\", \"/transactions\").as(\"createTransaction\")\ncy.intercept(\"PATCH\", \"/notifications/*\").as(\"updateNotification\")\ncy.intercept(\"POST\", \"/comments/*\").as(\"postComment\")\n```\n\nFinally, we are using another custom Cypress command `cy.databse()` to retrieve some users from the database and store them on the `ctx` object. This object and these users will be used later on within our tests.\nThis is an example of \"Data Driven Testing\" where instead of hard coding your data, you use real data from a remote source, which in this case is our database.\n\n```js\ncy.database(\"filter\", \"users\").then((users: User[]) => {\n  ctx.userA = users[0]\n  ctx.userB = users[1]\n  ctx.userC = users[2]\n})\n```\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Notifications Overview And Setup"},"url":"/real-world-examples/notifications-overview-and-setup","type":"lvl1"},{"title":"Renders An Empty Notifications State","content":"# renders an empty notifications state\n\nBefore continuing, make sure you have read the [Notifications Overview & Setup](/real-world-examples/notifications-overview-and-setup) lesson first.\n\n```js\nit(\"renders an empty notifications state\", function () {\n  cy.intercept(\"GET\", \"/notifications\", []).as(\"notifications\")\n\n  cy.loginByXstate(ctx.userA.username)\n\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click()\n  }\n  cy.getBySel(\"sidenav-notifications\").click()\n  cy.location(\"pathname\").should(\"equal\", \"/notifications\")\n  cy.getBySel(\"notification-list\").should(\"not.exist\")\n  cy.getBySel(\"empty-list-header\").should(\"contain\", \"No Notifications\")\n  cy.visualSnapshot(\"No Notifications\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept any **GET** request to the **/notifications** route. If you look closely, we are also passing in an empty array `[]` as a [3rd argument](https://docs.cypress.io/api/commands/intercept#Arguments) which will set the response data to be this empty array. The reason for this is we are trying to test what happens when a user does not have any notifications. The intercept is aliased to `@notifications`\n\n```js\ncy.intercept(\"GET\", \"/notifications\", []).as(\"notifications\")\n```\n\nThen, we use another custom Cypress command `cy.loginByXstate()` to log in as one of the users which we retrieved in the `beforeEach()` hook at the top of this spec file.\n\n```js\ncy.loginByXstate(ctx.userA.username)\n```\n\n![](/images/real-world-examples/notifications/renders-an-empty-notifications-state/Screen_Shot_2021-09-16_at_9.09.45_AM.png)\n\nIf this test is being run in a mobile viewport, we click on the button to toggle the sidebar.\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\n```\n\nNext, we click on the \"Notifications\" button in the sidebar and verify the app has routed us to the notifications screen.\n\n```js\ncy.getBySel(\"sidenav-notifications\").click()\ncy.location(\"pathname\").should(\"equal\", \"/notifications\")\n```\n\n![](/images/real-world-examples/notifications/renders-an-empty-notifications-state/Screen_Shot_2021-09-16_at_9.10.15_AM.png)\n\nFinally, we verify that there are not any notifications in the DOM and that the screen displays the correct text letting the user know there are no notifications.\n\n```js\ncy.getBySel(\"notification-list\").should(\"not.exist\")\ncy.getBySel(\"empty-list-header\").should(\"contain\", \"No Notifications\")\n```\n\n![](/images/real-world-examples/notifications/renders-an-empty-notifications-state/Screen_Shot_2021-09-16_at_9.10.31_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Renders An Empty Notifications State"},"url":"/real-world-examples/renders-an-empty-notifications-state","type":"lvl1"},{"title":"Custom Cypress Commands","content":"# Custom Cypress Commands\n\n## cy.createTransaction()\n\nThis custom command exists to create a transaction without using the UI. Since we already have a test that makes a transaction via the UI, we can use this command to complete a transaction much faster.\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"createTransaction\", (payload) => {\n  const log = Cypress.log({\n    name: \"createTransaction\",\n    displayName: \"CREATE TRANSACTION\",\n    message: [\n      `💸 (${payload.transactionType}): ${payload.sender.id} <> ${payload.receiver.id}`,\n    ],\n    // @ts-ignore\n    autoEnd: false,\n    consoleProps() {\n      return payload\n    },\n  })\n\n  return cy\n    .window({ log: false })\n    .then((win) => {\n      log.snapshot(\"before\")\n      win.createTransactionService.send(\"SET_USERS\", payload)\n\n      const createPayload = pick(\n        [\"amount\", \"description\", \"transactionType\"],\n        payload\n      )\n\n      return win.createTransactionService.send(\"CREATE\", {\n        ...createPayload,\n        senderId: payload.sender.id,\n        receiverId: payload.receiver.id,\n      })\n    })\n    .then(() => {\n      log.snapshot(\"after\")\n      log.end()\n    })\n})\n```\n\nFirst, we use [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log) to log out some custom information to the Cypress Command Log.\n\n```js\nconst log = Cypress.log({\n  name: \"createTransaction\",\n  displayName: \"CREATE TRANSACTION\",\n  message: [\n    `💸 (${payload.transactionType}): ${payload.sender.id} <> ${payload.receiver.id}`,\n  ],\n  // @ts-ignore\n  autoEnd: false,\n  consoleProps() {\n    return payload\n  },\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_11.10.06_AM.png)\n\nNext, we use <apiLink apiName=\"window\" displayName=\"cy.window()\" /> to grab the `window` object from the browser. Then we take a DOM snapshot and send the `SET_USERS` action to the `createTransactionService` from Xstate. We intentionally expose this service to the `window` object so that Cypress has access to it.\n\nThis service comes from the `createTransactionMachine` located at `src/machines/createTransactionMachine.ts` .\n\n```js\nreturn cy\n    .window({ log: false })\n    .then((win) => {\n      log.snapshot(\"before\");\n      win.createTransactionService.send(\"SET_USERS\", payload);\n```\n\nWe then create the payload for our transaction. [Pick](https://lodash.com/docs/4.17.15#pick) is a method from [Lodash](https://lodash.com/).\n\n```js\nconst createPayload = pick(\n  [\"amount\", \"description\", \"transactionType\"],\n  payload\n)\n```\n\nThen we send the `CREATE` action in the `createTransactionService` to create the transaction.\n\n```js\nreturn win.createTransactionService.send(\"CREATE\", {\n  ...createPayload,\n  senderId: payload.sender.id,\n  receiverId: payload.receiver.id,\n})\n```\n\nFinally, we take one final DOM snapshot.\n\n```js\n.then(() => {\n      log.snapshot(\"after\");\n      log.end();\n    });\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_11.17.16_AM.png)\n\n---\n\n## cy.database()\n\nThis command is responsible for retrieving data from the database in the [RWA](https://github.com/cypress-io/cypress-realworld-app). Often we will use the data returned from this command to drive our tests.\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\n  \"database\",\n  (operation, entity, query, logTask = false) => {\n    const params = {\n      entity,\n      query,\n    }\n\n    const log = Cypress.log({\n      name: \"database\",\n      displayName: \"DATABASE\",\n      message: [`🔎 ${operation}ing within ${entity} data`],\n      // @ts-ignore\n      autoEnd: false,\n      consoleProps() {\n        return params\n      },\n    })\n\n    return cy\n      .task(`${operation}:database`, params, { log: logTask })\n      .then((data) => {\n        log.snapshot()\n        log.end()\n        return data\n      })\n  }\n)\n```\n\nThe first thing we are doing is creating a `params` object comprised of the `entity` and `query` passed into the command.\n\n```js\nconst params = {\n  entity,\n  query,\n}\n```\n\nNext, we are creating a custom log with [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log).\n\n```js\nconst log = Cypress.log({\n  name: \"database\",\n  displayName: \"DATABASE\",\n  message: [`🔎 ${operation}ing within ${entity} data`],\n  // @ts-ignore\n  autoEnd: false,\n  consoleProps() {\n    return params\n  },\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_2.52.40_PM.png)\n\nFinally, we are returning a custom task which is responsible for performing whatever `operation` is passed into this command upon our database, either `find` or `filter`.\n\n```js\nreturn cy\n  .task(`${operation}:database`, params, { log: logTask })\n  .then((data) => {\n    log.snapshot()\n    log.end()\n    return data\n  })\n```\n\nThis task can be found in `cypress/plugins/index.ts` .\n\n```js\non(\"task\", {\n  percyHealthCheck,\n  async \"db:seed\"() {\n    // seed database with test data\n    const { data } = await axios.post(`${testDataApiEndpoint}/seed`)\n    return data\n  },\n\n  // fetch test data from a database (MySQL, PostgreSQL, etc...)\n  \"filter:database\"(queryPayload) {\n    return queryDatabase(queryPayload, (data, attrs) =>\n      _.filter(data.results, attrs)\n    )\n  },\n  \"find:database\"(queryPayload) {\n    return queryDatabase(queryPayload, (data, attrs) =>\n      _.find(data.results, attrs)\n    )\n  },\n})\n```\n\nYou may be wondering why we have created this as a [task](https://docs.cypress.io/api/commands/task) instead of a Custom Cypress Command. The reason is that Cypress [tasks](https://docs.cypress.io/api/commands/task) run in Node, while Cypress Custom Commands run in the browser.\n\n---\n\n## cy.getBySel()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"getBySel\", (selector, ...args) => {\n  return cy.get(`[data-test=${selector}]`, ...args)\n})\n```\n\nThis simple command takes in a selector and then returns the DOM element by using <apiLink apiName=\"get\" displayName=\"cy.get()\" />.\n\nFor example, without this command our code would look like this:\n\n```js\ncy.get('[data-test=\"signup-first-name\"]').type(\"Bob\")\ncy.get('[data-test=\"signup-last-name\"]').type(\"Ross\")\ncy.get('[data-test=\"signup-username\"]').type(\"PainterJoy90\")\ncy.get('[data-test=\"signup-password\"]').type(\"s3cret\")\ncy.get('[data-test=\"signup-confirmPassword\"]').type(\"s3cret\")\n```\n\nUsing this custom command our code now looks like this:\n\n```js\ncy.getBySel(\"signup-first-name\").type(\"Bob\")\ncy.getBySel(\"signup-last-name\").type(\"Ross\")\ncy.getBySel(\"signup-username\").type(\"PainterJoy90\")\ncy.getBySel(\"signup-password\").type(\"s3cret\")\ncy.getBySel(\"signup-confirmPassword\").type(\"s3cret\")\n```\n\n---\n\n## cy.getBySelLike()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"getBySelLike\", (selector, ...args) => {\n  return cy.get(`[data-test*=${selector}]`, ...args)\n})\n```\n\nThis simple command takes in a selector wildcard `*` and returns the DOM element using <apiLink apiName=\"get\" displayName=\"cy.get()\" />. It functions similarly to our `cy.getBySel()` custom command only this command will return multiple elements, whereas `cy.getBySel()` will return only one.\n\nFor example, below, we are getting all the transaction items and asserting that there are 3 of them in total.\n\n```js\ncy.getBySelLike(\"transaction-item\").should(\"have.length\", 3)\n```\n\nIn this example, we are clicking upon the first transaction.\n\n```js\ncy.getBySelLike(\"transaction-item\").first().click()\n```\n\n---\n\n## cy.login()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\n  \"login\",\n  (username, password, { rememberUser = false } = {}) => {\n    const signinPath = \"/signin\"\n    const log = Cypress.log({\n      name: \"login\",\n      displayName: \"LOGIN\",\n      message: [`🔐 Authenticating | ${username}`],\n      // @ts-ignore\n      autoEnd: false,\n    })\n\n    cy.intercept(\"POST\", \"/login\").as(\"loginUser\")\n    cy.intercept(\"GET\", \"checkAuth\").as(\"getUserProfile\")\n\n    cy.location(\"pathname\", { log: false }).then((currentPath) => {\n      if (currentPath !== signinPath) {\n        cy.visit(signinPath)\n      }\n    })\n\n    log.snapshot(\"before\")\n\n    cy.getBySel(\"signin-username\").type(username)\n    cy.getBySel(\"signin-password\").type(password)\n\n    if (rememberUser) {\n      cy.getBySel(\"signin-remember-me\").find(\"input\").check()\n    }\n\n    cy.getBySel(\"signin-submit\").click()\n    cy.wait(\"@loginUser\").then((loginUser: any) => {\n      log.set({\n        consoleProps() {\n          return {\n            username,\n            password,\n            rememberUser,\n            userId:\n              loginUser.response.statusCode !== 401 &&\n              loginUser.response.body.user.id,\n          }\n        },\n      })\n\n      log.snapshot(\"after\")\n      log.end()\n    })\n  }\n)\n```\n\nFirst, we create a constant called `signinPath` with the path for our sign-in page and use [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log) to log some additional information to the Cypress Command Log.\n\n```js\nconst signinPath = \"/signin\"\nconst log = Cypress.log({\n  name: \"login\",\n  displayName: \"LOGIN\",\n  message: [`🔐 Authenticating | ${username}`],\n  // @ts-ignore\n  autoEnd: false,\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_10.10.06_AM.png)\n\nNext, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept two requests and aliasing them.\n\n```js\ncy.intercept(\"POST\", \"/login\").as(\"loginUser\")\ncy.intercept(\"GET\", \"checkAuth\").as(\"getUserProfile\")\n```\n\nWe then check the `currentPath`, which is the URL in the browser's address bar. If it is not \"/signin,\" then we use `<apiLink apiName=\"visit\" displayName=\"cy.visit()\" /> to navigate to \"/signin.\"\n\n```js\ncy.location(\"pathname\", { log: false }).then((currentPath) => {\n  if (currentPath !== signinPath) {\n    cy.visit(signinPath)\n  }\n})\n```\n\nWe then take a DOM snapshot using [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log), which we declared above.\n\n```js\nlog.snapshot(\"before\")\n```\n\nWe then grab the username and password input fields and type in the username and password, respectively.\n\n```js\ncy.getBySel(\"signin-username\").type(username)\ncy.getBySel(\"signin-password\").type(password)\n```\n\nThen we have a conditional to check if we want to \"remember the user.\" By default, we set this to be `false` in the command signature.\n\n```js\nif (rememberUser) {\n  cy.getBySel(\"signin-remember-me\").find(\"input\").check()\n}\n```\n\nFinally, we click on the sign-in button and wait on the `@loginUser` intercept alias. We then use `log.set()` to set some of the login information in our [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log). We then take a final DOM snapshot and <apiLink apiName=\"end\" displayName=\".end()\" /> our log.\n\n```js\ncy.getBySel(\"signin-submit\").click()\ncy.wait(\"@loginUser\").then((loginUser: any) => {\n  log.set({\n    consoleProps() {\n      return {\n        username,\n        password,\n        rememberUser,\n        userId:\n          loginUser.response.statusCode !== 401 &&\n          loginUser.response.body.user.id,\n      }\n    },\n  })\n\n  log.snapshot(\"after\")\n  log.end()\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_10.10.06_AM.png)\n\n---\n\n## cy.loginByAPI()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\n  \"loginByApi\",\n  (username, password = Cypress.env(\"defaultPassword\")) => {\n    return cy.request(\"POST\", `${Cypress.env(\"apiUrl\")}/login`, {\n      username,\n      password,\n    })\n  }\n)\n```\n\nThis command logs in a user via one of our API endpoints. It takes the `username` and `password` and sends a `POST` request to our \"/login\" endpoint, and logs in our user.\n\nNote how we are using [Cypress.env()](https://docs.cypress.io/api/cypress-api/env) to handle our environment variables. You can find these in `cypres/plugins/index.ts` and `cypress.json`, respectively.\n\n---\n\n## cy.loginByXstate()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\n  \"loginByXstate\",\n  (username, password = Cypress.env(\"defaultPassword\")) => {\n    const log = Cypress.log({\n      name: \"loginbyxstate\",\n      displayName: \"LOGIN BY XSTATE\",\n      message: [`🔐 Authenticating | ${username}`],\n      autoEnd: false,\n    })\n\n    cy.intercept(\"POST\", \"/login\").as(\"loginUser\")\n    cy.intercept(\"GET\", \"/checkAuth\").as(\"getUserProfile\")\n    cy.visit(\"/signin\", { log: false }).then(() => {\n      log.snapshot(\"before\")\n    })\n\n    cy.window({ log: false }).then((win) =>\n      win.authService.send(\"LOGIN\", { username, password })\n    )\n\n    cy.wait(\"@loginUser\").then((loginUser) => {\n      log.set({\n        consoleProps() {\n          return {\n            username,\n            password,\n            // @ts-ignore\n            userId: loginUser.response.body.user.id,\n          }\n        },\n      })\n    })\n\n    return cy\n      .getBySel(\"list-skeleton\")\n      .should(\"not.exist\")\n      .then(() => {\n        log.snapshot(\"after\")\n        log.end()\n      })\n  }\n)\n```\n\nA lot is going on in this custom command, but we will break it down step by step.\n\nFirst, the command expects a username or password when it is invoked. We are providing a default password by using [Cypress.env()](https://docs.cypress.io/api/cypress-api/env).\n\nThis environment variable can be found in `cypress/plugins/index.ts` around line `15`.\n\n```js\nconfig.env.defaultPassword = process.env.SEED_DEFAULT_USER_PASSWORD\n```\n\nOn the left hand side we are setting the [Cypress.env()](https://docs.cypress.io/api/cypress-api/env) with our environment variable from the `.env` file in the root of the project around line `10`\n\n```js\nSEED_DEFAULT_USER_PASSWORD = s3cret\n```\n\nNext, we are creating some custom logging with [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log).\n\n```js\nconst log = Cypress.log({\n  name: \"loginbyxstate\",\n  displayName: \"LOGIN BY XSTATE\",\n  message: [`🔐 Authenticating | ${username}`],\n  autoEnd: false,\n})\n```\n\nThen, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept two requests and alias them.\n\n```js\ncy.intercept(\"POST\", \"/login\").as(\"loginUser\")\ncy.intercept(\"GET\", \"/checkAuth\").as(\"getUserProfile\")\n```\n\nThen, we visit the `/signin` route and take a DOM snapshot of the page.\n\n```js\ncy.visit(\"/signin\", { log: false }).then(() => {\n  log.snapshot(\"before\")\n})\n```\n\nNext, we log in our user by sending an event to the [XState](https://xstate.js.org/docs/) store, responsible for handling all of our client-side state around authentication. It is very similar to [Redux](https://redux.js.org/). The `authservice` is attached to the `window` object, so we use <apiLink apiName=\"window\" displayName=\"cy.window()\" /> to grab the `window` object from the browser. We intentionally expose this service to the `window` object so that Cypress has access to it. You can see an example of how we are doing this [here](https://github.com/cypress-io/cypress-realworld-app/blob/86bc319b33a98fc70a5c2e431e98307f5f28e532/src/containers/App.tsx#L17-L21).\n\nThen we trigger the `LOGIN` action with our username and password, which updates XState, and logs in the user.\n\n```js\ncy.window({ log: false }).then((win) =>\n  win.authService.send(\"LOGIN\", { username, password })\n)\n```\n\nWe are then using <apiLink apiName=\"wait\" displayName=\"cy.wait()\" /> on the `@loginUser` intercept alias and set some of the login data in our [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log) declared above.\n\n```js\nreturn cy.wait(\"@loginUser\").then((loginUser) => {\n    log.set({\n      consoleProps() {\n        return {\n          username,\n          password,\n          // @ts-ignore\n          userId: loginUser.response.body.user.id,\n        };\n      },\n    });\n```\n\nOnce complete, we set our custom log to log the user's information. This information will be logged to the browser's console when we click on this step in the Cypress UI.\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_10.47.45_AM.png)\n\nFinally, we write an assertion to confirm that the \"loading skeleton\" is no longer in the DOM and take a final DOM snapshot.\n\n```js\nreturn cy\n  .getBySel(\"list-skeleton\")\n  .should(\"not.exist\")\n  .then(() => {\n    log.snapshot(\"after\")\n    log.end()\n  })\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_10.49.15_AM.png)\n\n---\n\n## cy.logoutByXstate()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"logoutByXstate\", () => {\n  const log = Cypress.log({\n    name: \"logoutByXstate\",\n    displayName: \"LOGOUT BY XSTATE\",\n    message: [`🔒 Logging out current user`],\n    // @ts-ignore\n    autoEnd: false,\n  })\n\n  cy.window({ log: false }).then((win) => {\n    log.snapshot(\"before\")\n    win.authService.send(\"LOGOUT\")\n  })\n\n  return cy\n    .location(\"pathname\")\n    .should(\"equal\", \"/signin\")\n    .then(() => {\n      log.snapshot(\"after\")\n      log.end()\n    })\n})\n```\n\nFirst, we are using [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log) to log some custom information to the Cypress Command Log.\n\n```js\nconst log = Cypress.log({\n  name: \"logoutByXstate\",\n  displayName: \"LOGOUT BY XSTATE\",\n  message: [`🔒 Logging out current user`],\n  // @ts-ignore\n  autoEnd: false,\n})\n```\n\nNext, we log out our user by updating the [XState](https://xstate.js.org/docs/) store, which handles all of our client-side state around authentication. It is very similar to [Redux](https://redux.js.org/). The `authservice` is attached to the `window` object, so we use <apiLink apiName=\"window\" displayName=\"cy.window()\" /> to grab the `window` object from the browser. We intentionally expose this service to the `window` object so that Cypress has access to it. You can see an example of how we are doing this [here](https://github.com/cypress-io/cypress-realworld-app/blob/86bc319b33a98fc70a5c2e431e98307f5f28e532/src/containers/App.tsx#L17-L21).\n\nThen we trigger the `LOGOUT` action, which updates XState, and logs out the user.\n\n```js\ncy.window({ log: false }).then((win) => {\n  log.snapshot(\"before\")\n  win.authService.send(\"LOGOUT\")\n})\n```\n\nFinally, we write an assertion that the application redirects us to the \"/signin\" page after being logged out. We then take a final DOM snapshot.\n\n```js\nreturn cy\n  .location(\"pathname\")\n  .should(\"equal\", \"/signin\")\n  .then(() => {\n    log.snapshot(\"after\")\n    log.end()\n  })\n```\n\n---\n\n## cy.nextTransactionFeedPage()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"nextTransactionFeedPage\", (service, page) => {\n  const log = Cypress.log({\n    name: \"nextTransactionFeedPage\",\n    displayName: \"NEXT TRANSACTION FEED PAGE\",\n    message: [`📃 Fetching page ${page} with ${service}`],\n    // @ts-ignore\n    autoEnd: false,\n    consoleProps() {\n      return {\n        service,\n        page,\n      }\n    },\n  })\n\n  return cy\n    .window({ log: false })\n    .then((win) => {\n      log.snapshot(\"before\")\n      // @ts-ignore\n      return win[service].send(\"FETCH\", { page })\n    })\n    .then(() => {\n      log.snapshot(\"after\")\n      log.end()\n    })\n})\n```\n\nFirst, we are outputting some custom information to the Cypress Command Log.\n\n```js\nconst log = Cypress.log({\n  name: \"nextTransactionFeedPage\",\n  displayName: \"NEXT TRANSACTION FEED PAGE\",\n  message: [`📃 Fetching page ${page} with ${service}`],\n  // @ts-ignore\n  autoEnd: false,\n  consoleProps() {\n    return {\n      service,\n      page,\n    }\n  },\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_2.32.20_PM.png)\n\nNext, we are using <apiLink apiName=\"window\" displayName=\"cy.window()\" /> to grab the window object and take a DOM snapshot with `log.snapshot(\"before\")`. We then send the `FETCH` action to whichever service is passed in along with the page number. We use pagination in the application, so the page number represents which paginated page of transactions we would like to return.\n\nWe intentionally expose these services from our machines in Xstate to the `window` object so that Cypress has access to them.\n\nThen, we take one final DOM snapshot and end the log.\n\n```js\nreturn cy\n  .window({ log: false })\n  .then((win) => {\n    log.snapshot(\"before\")\n    // @ts-ignore\n    return win[service].send(\"FETCH\", { page })\n  })\n  .then(() => {\n    log.snapshot(\"after\")\n    log.end()\n  })\n```\n\n---\n\n## cy.pickDateRange()\n\nThis command is responsible for selecting dates from a 3rd party date picker. We decided to wrap this functionality into a command. It wraps some complex interactions with a 3rd party component, is used in multiple tests, and provides proper logging for what the command is doing in the Cypress Command Log.\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"pickDateRange\", (startDate, endDate) => {\n  const log = Cypress.log({\n    name: \"pickDateRange\",\n    displayName: \"PICK DATE RANGE\",\n    message: [`🗓 ${startDate.toDateString()} to ${endDate.toDateString()}`],\n    // @ts-ignore\n    autoEnd: false,\n    consoleProps() {\n      return {\n        startDate,\n        endDate,\n      }\n    },\n  })\n\n  const selectDate = (date: number) => {\n    return cy\n      .get(`[data-date='${formatDate(date, \"yyyy-MM-dd\")}']`)\n      .click({ force: true })\n  }\n\n  log.snapshot(\"before\")\n  // Focus initial viewable date picker range around target start date\n  // @ts-ignore\n  cy.clock(startDate.getTime(), [\"Date\"])\n\n  // Open date range picker\n  cy.getBySelLike(\"filter-date-range-button\").click({ force: true })\n  cy.get(\".Cal__Header__root\").should(\"be.visible\")\n\n  // Select date range\n  selectDate(startDate)\n  selectDate(endDate).then(() => {\n    log.snapshot(\"after\")\n    log.end()\n  })\n\n  cy.get(\".Cal__Header__root\").should(\"not.exist\")\n})\n```\n\nFirst, we are using [Cypress.log()](https://docs.cypress.io/api/cypress-api/cypress-log) to output some custom information to the Cypress Command Log.\n\n```js\nconst log = Cypress.log({\n  name: \"pickDateRange\",\n  displayName: \"PICK DATE RANGE\",\n  message: [`🗓 ${startDate.toDateString()} to ${endDate.toDateString()}`],\n  // @ts-ignore\n  autoEnd: false,\n  consoleProps() {\n    return {\n      startDate,\n      endDate,\n    }\n  },\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_2.39.52_PM.png)\n\nNext, we create a convenience function called `selectDate`, which gets the date picker and selects the date passed into it.\n\n```js\nconst selectDate = (date: number) => {\n  return cy\n    .get(`[data-date='${formatDate(date, \"yyyy-MM-dd\")}']`)\n    .click({ force: true })\n}\n```\n\nThen, we take a DOM snapshot and using <apiLink apiName=\"clock\" displayName=\"cy.clock()\" /> to set the current time based upon our start date.\n\n```js\nlog.snapshot(\"before\")\n// Focus initial viewable date picker range around target start date\n// @ts-ignore\ncy.clock(startDate.getTime(), [\"Date\"])\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_2.43.50_PM.png)\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_2.44.16_PM.png)\n\nNext, we click on the date range picker and assert that it is visible.\n\n```js\ncy.getBySelLike(\"filter-date-range-button\").click({ force: true })\ncy.get(\".Cal__Header__root\").should(\"be.visible\")\n```\n\nThen we use the `selectDate` function declared above to select both the starting and ending date of our range.\n\n```js\nselectDate(startDate)\nselectDate(endDate).then(() => {\n  log.snapshot(\"after\")\n  log.end()\n})\n```\n\nFinally, we assert that the date picker is closed after both dates are selected.\n\n```js\ncy.get(\".Cal__Header__root\").should(\"not.exist\")\n```\n\n---\n\n## cy.reactComponent()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"reactComponent\", { prevSubject: \"element\" }, ($el) => {\n  if ($el.length !== 1) {\n    throw new Error(\n      `cy.component() requires element of length 1 but got ${$el.length}`\n    )\n  }\n  // Query for key starting with __reactInternalInstance$ for React v16.x\n  //\n  const key = Object.keys($el.get(0)).find((key) =>\n    key.startsWith(\"__reactFiber$\")\n  )\n\n  // @ts-ignore\n  const domFiber = $el.prop(key)\n\n  Cypress.log({\n    name: \"component\",\n    consoleProps() {\n      return {\n        component: domFiber,\n      }\n    },\n  })\n\n  return domFiber.return\n})\n```\n\nThis command allows us to get access to a React component's props, in order to programmatically interact with them.\n\nFor instance, in the `setTransactionAmountRange` command, we need to trigger the `onChange` event for our React component. Still, to do that, we need the actual component, not the DOM element that <apiLink apiName=\"get\" displayName=\"cy.get()\" /> would return us. `cy.reactComponent()` queries the previously chained element for the [React Fiber instance](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber) to retrieve the props containing the `onChange` to call programmatically.\n\n## cy.setTransactionAmountRange()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"setTransactionAmountRange\", (min, max) => {\n  cy.getBySel(\"transaction-list-filter-amount-range-button\")\n    .scrollIntoView()\n    .click({ force: true })\n\n  return cy\n    .getBySelLike(\"filter-amount-range-slider\")\n    .reactComponent()\n    .its(\"memoizedProps\")\n    .invoke(\"onChange\", null, [min / 10, max / 10])\n})\n```\n\nFirst, we are getting the date range filter on the transaction page.\n\n```js\ncy.getBySel(\"transaction-list-filter-amount-range-button\")\n  .scrollIntoView()\n  .click({ force: true })\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_10.38.19_AM.png)\n\nWe then use the custom Cypress command `cy.reactComponent()` explained above, to set the min and max values of the slider. We are able to do this since the `cy.reactComponent()` command gives us access to the `memoizedProps` on the component which allows us to programmatically trigger the `onChange()` event setting the minimum and maximum values for the slider.\n\n```js\nreturn cy\n  .getBySelLike(\"filter-amount-range-slider\")\n  .reactComponent()\n  .its(\"memoizedProps\")\n  .invoke(\"onChange\", null, [min / 10, max / 10])\n```\n\nExample usage.\n\n```js\ncy.setTransactionAmountRange(200, 800)\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_10.39.06_AM.png)\n\n---\n\n## cy.switchUserByXstate()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"switchUserByXstate\", (username) => {\n  cy.logoutByXstate()\n  return cy.loginByXstate(username).then(() => {\n    if (isMobile()) {\n      cy.getBySel(\"sidenav-toggle\").click()\n      cy.getBySel(\"sidenav-username\").contains(username)\n      cy.getBySel(\"sidenav-toggle\").click({ force: true })\n    } else {\n      cy.getBySel(\"sidenav-username\").contains(username)\n    }\n    cy.getBySel(\"list-skeleton\").should(\"not.exist\")\n    cy.getBySelLike(\"transaction-item\").should(\"have.length.greaterThan\", 1)\n  })\n})\n```\n\nWe have two custom Cypress commands called `cy.logoutByXstate()` and `cy.loginByXstate()` . This command utilizes both to log out the current user and then log in as a new user, whose username we pass in when we invoke this command.\n\nWe then use our `isMobile()` utility function to determine if this test is being run inside a mobile viewport and click on the appropriate buttons.\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n  cy.getBySel(\"sidenav-username\").contains(username)\n  cy.getBySel(\"sidenav-toggle\").click({ force: true })\n} else {\n  cy.getBySel(\"sidenav-username\").contains(username)\n}\n```\n\nFinally, we write two assertions to ensure that the \"list skeleton\" on the transaction page is no longer in the DOM and that more than one transaction is displayed in the UI.\n\n```js\ncy.getBySel(\"list-skeleton\").should(\"not.exist\")\ncy.getBySelLike(\"transaction-item\").should(\"have.length.greaterThan\", 1)\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_11.04.58_AM.png)\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_11.05.06_AM.png)\n\n---\n\n## cy.visualSnapshot()\n\nLocated in `cypress/support/commands.ts` .\n\n```js\nCypress.Commands.add(\"visualSnapshot\", (maybeName) => {\n  // @ts-ignore\n  let snapshotTitle = cy.state(\"runnable\").fullTitle()\n  if (maybeName) {\n    snapshotTitle = snapshotTitle + \" - \" + maybeName\n  }\n  cy.percySnapshot(snapshotTitle, {\n    // @ts-ignore\n    widths: [cy.state(\"viewportWidth\")],\n    // @ts-ignore\n    minHeight: cy.state(\"viewportHeight\"),\n  })\n})\n```\n\n![](/images/real-world-examples/custom-commands/Screen_Shot_2021-09-21_at_9.43.27_AM.png)\n\nThe Cypress [Real World App (RWA)](https://github.com/cypress-io/cypress-realworld-app) uses the `cy.percySnapshot()` command provided by the Cypress Percy plugin to take visual snapshots throughout the user journey end-to-end tests. You can learn more about using Percy with Cypress [here](https://docs.cypress.io/guides/tooling/visual-testing#Percy).\n\nFirst, we create a variable called `snapshotTitle` that creates a title for our visual snapshot.\n\n```js\nlet snapshotTitle = cy.state(\"runnable\").fullTitle()\n```\n\nNext, if a string has been passed into our command, we append it to the end of our title.\n\n```js\nif (maybeName) {\n  snapshotTitle = snapshotTitle + \" - \" + maybeName\n}\n```\n\nIt is important that we provide a name for each snapshot and that each name is unique.\n\nFinally, we take a snapshot using the `cy.percySnapshot()` command and pass in the `snapshotTitle`, `width` and `minheight` from our current viewport. The `cy.percySnapshot()` command comes from a package created by the Percy team called @percy/cypress and can be found [here](https://github.com/percy/percy-cypress).\n\n```js\ncy.percySnapshot(snapshotTitle, {\n  // @ts-ignore\n  widths: [cy.state(\"viewportWidth\")],\n  // @ts-ignore\n  minHeight: cy.state(\"viewportHeight\"),\n})\n```\n\n---\n\n## cy.task(\"db:seed\")\n\nLocated in `cypress/plugins/index.ts` .\n\n```js\nasync \"db:seed\"() {\n  // seed database with test data\n  const { data } = await axios.post(`${testDataApiEndpoint}/seed`);\n  return data;\n},\n```\n\nThis task is responsible for making a request to an API endpoint, which triggers the backend to reseed the database. You will see this task quite frequently used within a `beforeEach()` so that we have freshly seeded data before each test is run. This reseeding technique is one of the strategies covered in the [Database Initialization & Seeding lesson](Database%20Initialization%20&%20Seeding%2012d7ce44bc424a3688a7839a7c7cef79.md).\n\n---\n\n## isMobile()\n\nLocated in `cypress/support/utils.ts` .\n\n```js\nexport const isMobile = () => {\n  return (\n    Cypress.config(\"viewportWidth\") <\n    Cypress.env(\"mobileViewportWidthBreakpoint\")\n  )\n}\n```\n\nThis function is a utility function used throughout our Cypress tests to determine if the viewport is a mobile device or not.\n\nBoth of the environment variables can be found inside the `cypress.json` file in the root of the repo.\n\n```json\n{\n  \"baseUrl\": \"http://localhost:3000\",\n  \"projectId\": \"7s5okt\",\n  \"integrationFolder\": \"cypress/tests\",\n  \"viewportHeight\": 1000,\n  \"viewportWidth\": 1280, // Cypress.config(\"viewportWidth\")\n  \"retries\": {\n    \"runMode\": 2,\n    \"openMode\": 1\n  },\n  \"env\": {\n    \"apiUrl\": \"http://localhost:3001\",\n    \"mobileViewportWidthBreakpoint\": 414, // Cypress.env(\"mobileViewportWidthBreakpoint\")\n    \"coverage\": false,\n    \"codeCoverage\": {\n      \"url\": \"http://localhost:3001/__coverage__\"\n    }\n  },\n  \"experimentalStudio\": true\n}\n```\n\nThis handy function will only be executed whenever our viewport width is less than `414px`.\n\nThis allows the same test to be used in both Desktop and Mobile orientations instead of coding mobile-specific tests.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Custom Cypress Commands"},"url":"/real-world-examples/custom-cypress-commands","type":"lvl1"},{"title":"Cypress Real World App Overview","content":"# Cypress Real World App Overview\n\n[The Real World App (RWA)](https://github.com/cypress-io/cypress-realworld-app) is an application created by the Cypress team that demonstrates real-world usage of Cypress testing methods, patterns, and workflows. Essentially, this application is a [Venmo](https://venmo.com/) clone. It allows users to sign up for an account, add a bank account and send/receive money between friends.\n\nThroughout this section, we will be using this application to learn a whole host of new Cypress features, testing strategies, and best practices. Before we begin, however, you must clone this repo down onto your machine to get everything set up and working correctly. We have made this process as painless and straightforward as possible.\n\nYou can find the repo [here](https://github.com/cypress-io/cypress-realworld-app).\n\nYou can clone the repo via the command line with:\n\n```bash\ngit clone git@github.com:cypress-io/cypress-realworld-app.git\n```\n\nIt might be best to first fork a copy of the repo and then clone the forked version.\n\nNote: The Cypress Real World App uses [Yarn](https://yarnpkg.com/) to manage its dependencies. Please install [Yarn](https://yarnpkg.com/) on your computer as installing with npm may lead to issues running the application.\n\nOnce cloned, change into the **cypress-realworld-app** directory and install all of the npm dependencies using Yarn.\n\n```bash\nyarn install\n```\n\nYou can then run the application with\n\n```bash\nyarn dev\n```\n\nOnce the application is up and running, a browser window should open a new tab to **http://localhost:3000**, where you should see the Sign In page.\n\n![](/images/real-world-examples/overview/cypress-real-world-app-overview/Screen_Shot_2021-06-28_at_11.32.22_AM.png)\n\nRefer to the **README.md** file in the repo for additional information and instructions.\n\nWe provide a set of default users in the database, or you can create your own account. We recommend you first log in with one of the default users to see some of the sample data seeded in the app.\n\nYou can list out all of the default users with this command.\n\n```bash\nyarn list:dev:users\n```\n\nEvery user's password is **s3cret**.\n\nFor example, you can use the following username and password to log in.\n\n```bash\nUsername: Katharina_Bernier\nPassword: s3cret\n```\n\nOnce logged in, you will see the main dashboard.\n\n![](/images/real-world-examples/overview/cypress-real-world-app-overview/Screen_Shot_2021-09-16_at_1.40.27_PM.png)\n\nYou don't need to spend a ton of time here, but having a general sense of what the app does will be very important for future lessons. Since we will be writing several tests for this application, we need to have a good understanding of what it does so that we can write the proper tests.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Cypress Real World App Overview"},"url":"/real-world-examples/cypress-real-world-app-overview","type":"lvl1"},{"title":"Our Approach To Testing The Real World App","content":"# Our Approach to Testing the RWA\n\nUnderstanding how to test an application's various paths (or components) is the most challenging part of testing. As the Real World App was being developed, we used multiple testing strategies throughout the development process. We recommend applying these strategies as they provide proven layers of testing at the right time while building your application.\n\n## Which types of tests and why\n\nSeeing how the [RWA](https://github.com/cypress-io/cypress-realworld-app) is a full-stack application, we needed to write tests that would test both the back-end and the front-end. As the back-end was being developed, we wrote unit tests and integration tests to ensure that APIs worked as expected. As the front-end was being developed, we wrote end-to-end tests with Cypress to ensure the UI worked.\n\nIt is often best to write unit tests and integration tests during the development of back-end's since you do not have a UI to interact with yet. Once the UI is complete, you can add E2E tests to test the entire stack from the database layer through the network layer to the UI.\n\n## Defining our Testing Strategy\n\n![](/images/real-world-examples/overview/our-approach-to-testing-the-real-world-app/Pay_App.png)\n\nBefore writing any E2E tests, we defined our testing strategy that visually documented the application's most important areas for test coverage. Our recommended approach is first to document all the application screens, taking notes on the functionality that needs to be tested on each.\n\nThinking through your application upfront makes writing your tests much more straightforward. It also allows you to break up the work amongst various developers, tickets, etc. Visual documentation like the example above acts like a kind of \"map,\" which helps to provide a high-level overview of your application's testing surface.\n\n## User Journeys\n\nUser Journeys are the paths users take throughout your application that lead to the most valuable tests you can write.\n\nAfter documenting the functionality from each view/screen, we documented the various user journeys a user of our application could take.\n\nFor example, we have a single test that creates a new account, logs in to that new account create a new bank account, and logs out. With a single test, we are testing some of the most critical functionality of our app and the database, APIs, and UI that makes it all possible.\n\nTesting user journeys is incredibly important and powerful. We will walk you through some examples in upcoming lessons.\n\n## Testing Strategies for teams\n\nMost companies have dedicated back-end and front-end teams, and often development teams do not know how to test the areas they are responsible for. For example, how is the front-end team supposed to test the UI if the APIs being developed by the back-end team are not ready yet?\n\nA solution for this is to have your back-end team provide you with a sample API payload which you can then mock to write your tests against. Then when those APIs are ready, you remove the mock and test against the actual APIs.\n\nBack-end teams should be writing unit tests and integration tests while developing their features to ensure that everything is working correctly. Then once the UI is in place, those integration tests can be replaced by E2E tests.\n\n## Getting Real\n\nLet's be honest; what we have just described is an ideal scenario. We know that in the real world, things get messy, and teams seldomly follow \"best practices,\" even though they know they should. You have deadlines and often unrealistic expectations placed upon you. We get it.\n\nTesting is hard, and no one does it perfectly, not even us. However, if you adopt some of these strategies, you will have fewer bugs in the features you ship and more confidence each time you push to production.\n\nSo remember, a helpful strategy for writing tests is first to document what your application does and the most important features you want to test. Then test \"user journeys,\" which will imitate what actual users of your application will do to ensure that everything is working correctly.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Our Approach To Testing The Real World App"},"url":"/real-world-examples/our-approach-to-testing-the-real-world-app","type":"lvl1"},{"title":"App Layout And Responsiveness","content":"# app layout and responsiveness\n\nBefore continuing, make sure you have read the [Transaction Feeds Overview & Setup](/real-world-examples/transaction-feeds-overview-and-setup) lesson first.\n\n```js\ndescribe(\"app layout and responsiveness\", function () {\n  it(\"toggles the navigation drawer\", function () {\n    cy.wait(\"@notifications\")\n    cy.wait(\"@publicTransactions\")\n    if (isMobile()) {\n      cy.getBySel(\"sidenav-home\").should(\"not.exist\")\n      cy.visualSnapshot(\"Mobile Initial Side Navigation Not Visible\")\n      cy.getBySel(\"sidenav-toggle\").click()\n      cy.getBySel(\"sidenav-home\").should(\"be.visible\")\n      cy.visualSnapshot(\"Mobile Toggle Side Navigation Visible\")\n      cy.get(\".MuiBackdrop-root\").click({ force: true })\n      cy.getBySel(\"sidenav-home\").should(\"not.exist\")\n      cy.visualSnapshot(\"Mobile Home Link Side Navigation Not Visible\")\n\n      cy.getBySel(\"sidenav-toggle\").click()\n      cy.getBySel(\"sidenav-home\").click().should(\"not.exist\")\n      cy.visualSnapshot(\"Mobile Toggle Side Navigation Not Visible\")\n    } else {\n      cy.getBySel(\"sidenav-home\").should(\"be.visible\")\n      cy.visualSnapshot(\"Desktop Side Navigation Visible\")\n      cy.getBySel(\"sidenav-toggle\").click()\n      cy.getBySel(\"sidenav-home\").should(\"not.be.visible\")\n      cy.visualSnapshot(\"Desktop Side Navigation Not Visible\")\n    }\n  })\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nThis test is relatively straightforward, and we will not be covering every single line. The general purpose of this test is to make sure that certain elements are either visible or invisible depending upon whether we are in a mobile viewport or not.\nWe also use several `cy.visualSnapshot()` to confirm that our UI has not changed. Tests like these are essential as they demonstrate the importance of testing what is there and what should not be there.\nRemember, you do not want to only test for the positive or \"happy paths\"; you also want to test the negative or \"unhappy paths.\"\n\n---\n\nThe first thing we are doing is waiting on a couple of intercepts that occur in the `.beforeEach()` hook.\n\n```js\ncy.wait(\"@notifications\")\ncy.wait(\"@publicTransactions\")\n```\n\n![](/images/real-world-examples/transaction-feeds/app-layout-and-responsiveness/Screen_Shot_2021-09-16_at_9.29.28_AM.png)\n\nNext, we use our `isMobile()` utility method to determine if this test is being run in a mobile viewport or not.\n\n```js\nif (isMobile()) {\n// ...\n\n```\n\nIf we are in a mobile viewport, then we verify the certain elements are visible or not visible when we click on various buttons.\n\n```js\ncy.getBySel(\"sidenav-home\").should(\"not.exist\")\ncy.visualSnapshot(\"Mobile Initial Side Navigation Not Visible\")\ncy.getBySel(\"sidenav-toggle\").click()\ncy.getBySel(\"sidenav-home\").should(\"be.visible\")\ncy.visualSnapshot(\"Mobile Toggle Side Navigation Visible\")\ncy.get(\".MuiBackdrop-root\").click({ force: true })\ncy.getBySel(\"sidenav-home\").should(\"not.exist\")\ncy.visualSnapshot(\"Mobile Home Link Side Navigation Not Visible\")\n\ncy.getBySel(\"sidenav-toggle\").click()\ncy.getBySel(\"sidenav-home\").click().should(\"not.exist\")\ncy.visualSnapshot(\"Mobile Toggle Side Navigation Not Visible\")\n```\n\nIf we are not in a mobile viewport, then verify that certain elements are visible or not for desktop and greater viewports.\n\n```js\ncy.getBySel(\"sidenav-home\").should(\"be.visible\")\ncy.visualSnapshot(\"Desktop Side Navigation Visible\")\ncy.getBySel(\"sidenav-toggle\").click()\ncy.getBySel(\"sidenav-home\").should(\"not.be.visible\")\ncy.visualSnapshot(\"Desktop Side Navigation Not Visible\")\n```\n\n![](/images/real-world-examples/transaction-feeds/app-layout-and-responsiveness/Screen_Shot_2021-09-16_at_9.30.10_AM.png)\n\n![](/images/real-world-examples/transaction-feeds/app-layout-and-responsiveness/Screen_Shot_2021-09-16_at_9.30.14_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"App Layout And Responsiveness"},"url":"/real-world-examples/app-layout-and-responsiveness","type":"lvl1"},{"title":"Filters Transaction Feeds By Date Range","content":"# filters transaction feeds by date range\n\nBefore continuing, make sure you have read the [Transaction Feeds Overview & Setup](/real-world-examples/transaction-feeds-overview-and-setup) lesson first.\n\n```js\ndescribe(\"filters transaction feeds by date range\", function () {\n  if (isMobile()) {\n    it(\"closes date range picker modal\", () => {\n      cy.getBySelLike(\"filter-date-range-button\").click({ force: true })\n      cy.get(\".Cal__Header__root\").should(\"be.visible\")\n      cy.visualSnapshot(\"Mobile Open Date Range Picker\")\n      cy.getBySel(\"date-range-filter-drawer-close\").click()\n      cy.get(\".Cal__Header__root\").should(\"not.exist\")\n      cy.visualSnapshot(\"Mobile Close Date Range Picker\")\n    })\n  }\n\n  _.each(feedViews, (feed, feedName) => {\n    it(`filters ${feedName} transaction feed by date range`, function () {\n      cy.database(\"find\", \"transactions\").then((transaction: Transaction) => {\n        const dateRangeStart = startOfDay(new Date(transaction.createdAt))\n        const dateRangeEnd = endOfDayUTC(addDays(dateRangeStart, 1))\n\n        cy.getBySelLike(feed.tab).click().should(\"have.class\", \"Mui-selected\")\n\n        cy.wait(`@${feed.routeAlias}`)\n          .its(\"response.body.results\")\n          .as(\"unfilteredResults\")\n\n        cy.pickDateRange(dateRangeStart, dateRangeEnd)\n\n        cy.wait(`@${feed.routeAlias}`)\n          .its(\"response.body.results\")\n          .then((transactions: Transaction[]) => {\n            cy.getBySelLike(\"transaction-item\").should(\n              \"have.length\",\n              transactions.length\n            )\n\n            transactions.forEach(({ createdAt }) => {\n              const createdAtDate = startOfDayUTC(new Date(createdAt))\n\n              expect(\n                isWithinInterval(createdAtDate, {\n                  start: startOfDayUTC(dateRangeStart),\n                  end: dateRangeEnd,\n                }),\n                `transaction created date (${createdAtDate.toISOString()})\n                  is within ${dateRangeStart.toISOString()}\n                  and ${dateRangeEnd.toISOString()}`\n              ).to.equal(true)\n            })\n\n            cy.visualSnapshot(\"Date Range Filtered Transactions\")\n          })\n\n        cy.log(\"Clearing date range filter. Data set should revert\")\n        cy.getBySelLike(\"filter-date-clear-button\").click({\n          force: true,\n        })\n        cy.getBySelLike(\"filter-date-range-button\").should(\"contain\", \"ALL\")\n\n        cy.get(\"@unfilteredResults\").then((unfilteredResults) => {\n          cy.wait(`@${feed.routeAlias}`)\n            .its(\"response.body.results\")\n            .should(\"deep.equal\", unfilteredResults)\n          cy.visualSnapshot(\"Unfiltered Transactions\")\n        })\n      })\n    })\n\n    it(`does not show ${feedName} transactions for out of range date limits`, function () {\n      const dateRangeStart = startOfDay(new Date(2014, 1, 1))\n      const dateRangeEnd = endOfDayUTC(addDays(dateRangeStart, 1))\n\n      cy.getBySelLike(feed.tab).click()\n      cy.wait(`@${feed.routeAlias}`)\n\n      cy.pickDateRange(dateRangeStart, dateRangeEnd)\n      cy.wait(`@${feed.routeAlias}`)\n\n      cy.getBySelLike(\"transaction-item\").should(\"have.length\", 0)\n      cy.getBySel(\"empty-list-header\").should(\"contain\", \"No Transactions\")\n      cy.getBySelLike(\"empty-create-transaction-button\")\n        .should(\"have.attr\", \"href\", \"/transaction/new\")\n        .contains(\"create a transaction\", { matchCase: false })\n        .should(\"have.css\", { \"text-transform\": \"uppercase\" })\n      cy.visualSnapshot(\"No Transactions\")\n    })\n  })\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we are checking to see if our test is being run inside of a mobile viewport. If so, we ensure that the data range picker works properly on a mobile device by clicking on it to open it, confirming that it is open, and then closing it.\n\n```js\nif (isMobile()) {\n  it(\"closes date range picker modal\", () => {\n    cy.getBySelLike(\"filter-date-range-button\").click({ force: true })\n    cy.get(\".Cal__Header__root\").should(\"be.visible\")\n    cy.visualSnapshot(\"Mobile Open Date Range Picker\")\n    cy.getBySel(\"date-range-filter-drawer-close\").click()\n    cy.get(\".Cal__Header__root\").should(\"not.exist\")\n    cy.visualSnapshot(\"Mobile Close Date Range Picker\")\n  })\n}\n```\n\nNext, we loop through each property inside the `feedViews` object, which we defined in the `beforeEach()` at the top of the spec file.\n\n```js\nconst feedViews = {\n    public: {\n      tab: \"public-tab\",\n      tabLabel: \"everyone\",\n      routeAlias: \"publicTransactions\",\n      service: \"publicTransactionService\",\n    },\n    contacts: {\n      tab: \"contacts-tab\",\n      tabLabel: \"friends\",\n      routeAlias: \"contactsTransactions\",\n      service: \"contactTransactionService\",\n    },\n    personal: {\n      tab: \"personal-tab\",\n      tabLabel: \"mine\",\n      routeAlias: \"personalTransactions\",\n      service: \"personalTransactionService\",\n    },\n  };\n\n// ..\n\n_.each(feedViews, (feed, feedName) => {\n```\n\nWe then create a test for each `feedView` dynamically.\n\n```js\nit.only(`filters ${feedName} transaction feed by date range`, function () {\n```\n\nNext, we use a custom Cypress command `cy.database()` to find some transactions from the database.\n\n```js\ncy.database(\"find\", \"transactions\").then((transaction: Transaction) => {\n```\n\nThen, we click on the appropriate tab for our feed.\n\n```js\ncy.getBySelLike(feed.tab).click().should(\"have.class\", \"Mui-selected\")\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.42.01_AM.png)\n\nNext we wait on the intercept associated with the feed.\n\n```js\ncy.wait(`@${feed.routeAlias}`)\n  .its(\"response.body.results\")\n  .as(\"unfilteredResults\")\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.43.33_AM.png)\n\nNext, we use another custom Cypress command `cy.pickDateRange()` to pick select the dates we want.\n\n```js\ncy.pickDateRange(dateRangeStart, dateRangeEnd)\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.43.54_AM.png)\n\nThen, we wait on the intercept associated with the feed and grab the results from the reponse.\n\n```js\ncy.wait(`@${feed.routeAlias}`).its(\"response.body.results\")\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.46.05_AM.png)\n\nWe then confirm that all of the results are displayed in the UI.\n\n```js\ncy.getBySelLike(\"transaction-item\").should(\"have.length\", transactions.length)\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.47.48_AM.png)\n\nThen we loop through all of the transactions and make sure that all of the transaction dates are within the correct range.\n\n- `startOfDayUTC` is a utility function that can be found in **src/utils/transactionUtils.ts**\n- `isWithinInterval` is a function from the [date-fns](https://date-fns.org/) library.\n\n```js\ntransactions.forEach(({ createdAt }) => {\n  const createdAtDate = startOfDayUTC(new Date(createdAt))\n\n  expect(\n    isWithinInterval(createdAtDate, {\n      start: startOfDayUTC(dateRangeStart),\n      end: dateRangeEnd,\n    }),\n    `transaction created date (${createdAtDate.toISOString()}) \n                  is within ${dateRangeStart.toISOString()} \n                  and ${dateRangeEnd.toISOString()}`\n  ).to.equal(true)\n})\n```\n\nWe then use <apiLink apiName=\"log\" displayName=\"cy.log()\" /> to output a custom message to the Cypress Command Log.\n\n```js\ncy.log(\"Clearing date range filter. Data set should revert\")\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.55.33_AM.png)\n\nNext, we clear the date range picker.\n\n```js\ncy.getBySelLike(\"filter-date-clear-button\").click({\n  force: true,\n})\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.57.16_AM.png)\n\nFinally, we make sure that all of the transactions are displayed now that we have cleared the date range picker, meaning that we are no longer filtering the results.\n\n```js\ncy.get(\"@unfilteredResults\").then((unfilteredResults) => {\n  cy.wait(`@${feed.routeAlias}`)\n    .its(\"response.body.results\")\n    .should(\"deep.equal\", unfilteredResults)\n  cy.visualSnapshot(\"Unfiltered Transactions\")\n})\n```\n\n![](/images/real-world-examples/transaction-feeds/filters-transaction-feeds-by-date-range/Screen_Shot_2021-09-16_at_9.58.15_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Filters Transaction Feeds By Date Range"},"url":"/real-world-examples/filters-transaction-feeds-by-date-range","type":"lvl1"},{"title":"Mine Feed Only Shows Personal Transactions","content":"# mine feed only shows personal transactions\n\nBefore continuing, make sure you have read the [Transaction Feeds Overview & Setup](/real-world-examples/transaction-feeds-overview-and-setup) lesson first.\n\n```js\nit(\"mine feed only shows personal transactions\", function () {\n      cy.database(\"filter\", \"contacts\", { userId: ctx.user!.id }).then((contacts: Contact[]) => {\n        ctx.contactIds = contacts.map((contact) => contact.contactUserId);\n      });\n\n      cy.getBySelLike(feedViews.personal.tab).click();\n\n      cy.wait(\"@personalTransactions\")\n        .its(\"response.body.results\")\n        .each((transaction: Transaction) => {\n          const transactionParticipants = [transaction.senderId, transaction.receiverId];\n          expect(transactionParticipants).to.include(ctx.user!.id);\n        });\n      cy.getBySel(\"list-skeleton\").should(\"not.exist\");\n      cy.visualSnapshot(\"Personal Transactions\");\n    });\n\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we are using a custom Cypress command `cy.database()` to filter through the `contacts` of the user from the `ctx` object. Remember, the `ctx` object's data is setup in the `beforeEach()` hook at the top of this spec file. We `.map()` over all of the user's contacts and store their `id`'s on the `ctx` object.\n\n```js\ncy.database(\"filter\", \"contacts\", { userId: ctx.user!.id }).then((contacts: Contact[]) => {\n        ctx.contactIds = contacts.map((contact) => contact.contactUserId);\n      });\n\n```\n\n![](/images/real-world-examples/transaction-feeds/mine-feed-only-shows-personal-transactions/Screen_Shot_2021-09-16_at_9.31.36_AM.png)\n\nNext, we click on the personal feed view tab\n\n```js\ncy.getBySelLike(feedViews.personal.tab).click()\n```\n\n![](/images/real-world-examples/transaction-feeds/mine-feed-only-shows-personal-transactions/Screen_Shot_2021-09-16_at_9.31.55_AM.png)\n\nThen, we wait upon the `@personalTransactions` intercept, grab the `results` from the body of the response and iterate over each transaction. We then make an assertion to make sure the response only returns transactions associated with our user.\n\n```js\ncy.wait(\"@personalTransactions\")\n        .its(\"response.body.results\")\n        .each((transaction: Transaction) => {\n          const transactionParticipants = [transaction.senderId, transaction.receiverId];\n          expect(transactionParticipants).to.include(ctx.user!.id);\n        });\n\n```\n\n![](/images/real-world-examples/transaction-feeds/mine-feed-only-shows-personal-transactions/Screen_Shot_2021-09-16_at_9.32.18_AM.png)\n\nFinally, we make sure that the loading skeleton does not exist in the DOM.\n\n```js\ncy.getBySel(\"list-skeleton\").should(\"not.exist\")\n```\n\n![](/images/real-world-examples/transaction-feeds/mine-feed-only-shows-personal-transactions/Screen_Shot_2021-09-16_at_9.32.34_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Mine Feed Only Shows Personal Transactions"},"url":"/real-world-examples/mine-feed-only-shows-personal-transactions","type":"lvl1"},{"title":"Renders Transactions Item Variations In Feed","content":"# renders transactions item variations in feed\n\nBefore continuing, make sure you have read the [Transaction Feeds Overview & Setup](/real-world-examples/transaction-feeds-overview-and-setup) lesson first.\n\n```js\ndescribe(\"renders and paginates all transaction feeds\", function () {\n    it(\"renders transactions item variations in feed\", function () {\n      cy.intercept(\"GET\", \"/transactions/public*\", {\n        headers: {\n          \"X-Powered-By\": \"Express\",\n          Date: new Date().toString(),\n        },\n        fixture: \"public-transactions.json\",\n      }).as(\"mockedPublicTransactions\");\n\n      // Visit page again to trigger call to /transactions/public\n      cy.visit(\"/\");\n\n      cy.wait(\"@notifications\");\n      cy.wait(\"@mockedPublicTransactions\")\n        .its(\"response.body.results\")\n        .then((transactions) => {\n          const getTransactionFromEl = ($el: JQuery<Element>): TransactionResponseItem => {\n            const transactionId = $el.data(\"test\").split(\"transaction-item-\")[1];\n            return _.find(transactions, (transaction) => {\n              return transaction.id === transactionId;\n            })!;\n          };\n\n          cy.log(\"🚩Testing a paid payment transaction item\");\n          cy.contains(\"[data-test*='transaction-item']\", \"paid\").within(($el) => {\n            const transaction = getTransactionFromEl($el);\n            const formattedAmount = Dinero({\n              amount: transaction.amount,\n            }).toFormat();\n\n            expect([TransactionStatus.pending, TransactionStatus.complete]).to.include(\n              transaction.status\n            );\n\n            expect(transaction.requestStatus).to.be.empty;\n\n            cy.getBySelLike(\"like-count\").should(\"have.text\", `${transaction.likes.length}`);\n            cy.getBySelLike(\"comment-count\").should(\"have.text\", `${transaction.comments.length}`);\n\n            cy.getBySelLike(\"sender\").should(\"contain\", transaction.senderName);\n            cy.getBySelLike(\"receiver\").should(\"contain\", transaction.receiverName);\n\n            cy.getBySelLike(\"amount\")\n              .should(\"contain\", `-${formattedAmount}`)\n              .should(\"have.css\", \"color\", \"rgb(255, 0, 0)\");\n          });\n\n          cy.log(\"🚩Testing a charged payment transaction item\");\n          cy.contains(\"[data-test*='transaction-item']\", \"charged\").within(($el) => {\n            const transaction = getTransactionFromEl($el);\n            const formattedAmount = Dinero({\n              amount: transaction.amount,\n            }).toFormat();\n\n            expect(TransactionStatus.complete).to.equal(transaction.status);\n\n            expect(transaction.requestStatus).to.equal(TransactionRequestStatus.accepted);\n\n            cy.getBySelLike(\"amount\")\n              .should(\"contain\", `+${formattedAmount}`)\n              .should(\"have.css\", \"color\", \"rgb(76, 175, 80)\");\n          });\n\n          cy.log(\"🚩Testing a requested payment transaction item\");\n          cy.contains(\"[data-test*='transaction-item']\", \"requested\").within(($el) => {\n            const transaction = getTransactionFromEl($el);\n            const formattedAmount = Dinero({\n              amount: transaction.amount,\n            }).toFormat();\n\n            expect([TransactionStatus.pending, TransactionStatus.complete]).to.include(\n              transaction.status\n            );\n            expect([\n              TransactionRequestStatus.pending,\n              TransactionRequestStatus.rejected,\n            ]).to.include(transaction.requestStatus);\n\n            cy.getBySelLike(\"amount\")\n              .should(\"contain\", `+${formattedAmount}`)\n              .should(\"have.css\", \"color\", \"rgb(76, 175, 80)\");\n          });\n          cy.visualSnapshot(\"Transaction Item\");\n        });\n    });\n\n    _.each(feedViews, (feed, feedName) => {\n      it(`paginates ${feedName} transaction feed`, function () {\n        cy.getBySelLike(feed.tab)\n          .click()\n          .should(\"have.class\", \"Mui-selected\")\n          .contains(feed.tabLabel, { matchCase: false })\n          .should(\"have.css\", { \"text-transform\": \"uppercase\" });\n        cy.getBySel(\"list-skeleton\").should(\"not.exist\");\n        cy.visualSnapshot(`Paginate ${feedName}`);\n\n        cy.wait(`@${feed.routeAlias}`)\n          .its(\"response.body.results\")\n          .should(\"have.length\", Cypress.env(\"paginationPageSize\"));\n\n        // Temporary fix: <https://github.com/cypress-io/cypress-realworld-app/issues/338>\n        if (isMobile()) {\n          cy.wait(10);\n        }\n\n        cy.log(\"📃 Scroll to next page\");\n        cy.getBySel(\"transaction-list\").children().scrollTo(\"bottom\");\n\n        cy.wait(`@${feed.routeAlias}`)\n          .its(\"response.body\")\n          .then(({ results, pageData }) => {\n            expect(results).have.length(Cypress.env(\"paginationPageSize\"));\n            expect(pageData.page).to.equal(2);\n            cy.visualSnapshot(`Paginate ${feedName} Next Page`);\n            cy.nextTransactionFeedPage(feed.service, pageData.totalPages);\n          });\n\n        cy.wait(`@${feed.routeAlias}`)\n          .its(\"response.body\")\n          .then(({ results, pageData }) => {\n            expect(results).to.have.length.least(1);\n            expect(pageData.page).to.equal(pageData.totalPages);\n            expect(pageData.hasNextPages).to.equal(false);\n            cy.visualSnapshot(`Paginate ${feedName} Last Page`);\n          });\n      });\n    });\n  });\n\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept any **GET** request to the **/transactions/public\\*** route.\n\n```js\ncy.intercept(\"GET\", \"/transactions/public*\", {\n```\n\nWe are also adding two additional headers to the response's headers. These headers will be appended to the original response headers, leaving the original ones intact.\n\n```js\nheaders: {\n          \"X-Powered-By\": \"Express\",\n          Date: new Date().toString(),\n        },\n```\n\nWe are then using a fixture to mock the response's payload. This fixture can be found inside of **cypress/fixtures**\n\n```js\nfixture: \"public-transactions.json\",\n      }).as(\"mockedPublicTransactions\");\n```\n\nThen we visit the root route to trigger the **GET** request to **/transactions/public**\n\n```js\n// Visit page again to trigger call to /transactions/public\ncy.visit(\"/\")\n```\n\nNext, we wait for two intercepts.\n\n```js\ncy.wait(\"@notifications\")\ncy.wait(\"@mockedPublicTransactions\")\n```\n\nWe then grab the results from the `@mockedPublicTransactions` intercept. Remember, these results are coming from our **public-transactions.json** fixture.\n.its(\"response.body.results\")\n\n```js\n.its(\"response.body.results\")\n\n```\n\n![](/images/real-world-examples/transaction-feeds/renders-transactions-item-variations-in-feed/Screen_Shot_2021-09-16_at_10.12.03_AM.png)\n\nThen, we have a function called `getTransactionFromEl` which finds the `transactionID` from the transaction element in the DOM. This function is a little complicated, so let's break it down line by line.\n\n```js\n.then((transactions) => {\n          const getTransactionFromEl = ($el: JQuery<Element>): TransactionResponseItem => {\n            const transactionId = $el.data(\"test\").split(\"transaction-item-\")[1];\n            return _.find(transactions, (transaction) => {\n              return transaction.id === transactionId;\n            })!;\n          };\n```\n\n```js\nconst getTransactionFromEl = ($el: JQuery<Element>): TransactionResponseItem => {\n```\n\nOur function `getTransactionFromEl` accepts a jQuery element as a parameter and returns a `TransactionResponseItem` which is a TypeScript interface which can be found in **src/models/transaction.ts** around line **50** .\n\n```js\nconst transactionId = $el.data(\"test\").split(\"transaction-item-\")[1]\n```\n\nNext, we get the transactionID from the **data-test** attribute from the DOM. For example the HTML for one of our transactions looks like this.\n\n```js\n<li\n\tclass=\"MuiListItem-root MuiListItem-gutters MuiListItem-alignItemsFlexStart\"\n  data-test=\"transaction-item-183VHWyuQMS\">\n```\n\nOnce we have the string located within the **data-test** attribute, we use `.split()` to grab the `transactionID`\n\n```js\n\"transaction-item-183VHWyuQMS\".split(\"transaction-item-\")[1]\n// \"183VHWyuQMS\"\n```\n\nThen, we use `_.find()` from [Lodash](https://lodash.com/docs/4.17.15#find) to locate the transaction from the `@mockedPublicTransactions` request. using the ID we just located from the DOM .\n\n```js\nreturn _.find(transactions, (transaction) => {\n              return transaction.id === transactionId;\n            })!;\n```\n\nWe then use <apiLink apiName=\"log\" displayName=\"cy.log()\" /> to output a custom message to the Cypress Command Log.\n\n```js\ncy.log(\"🚩Testing a paid payment transaction item\")\n```\n\n![](/images/real-world-examples/transaction-feeds/renders-transactions-item-variations-in-feed/Screen_Shot_2021-09-17_at_9.35.22_AM.png)\n\nNext, we are looking for a \"paid\" transaction, which in this case is the first transaction in the list.\n\n```js\ncy.contains(\"[data-test*='transaction-item']\", \"paid\").within(($el) => {\n```\n\n![](/images/real-world-examples/transaction-feeds/renders-transactions-item-variations-in-feed/Screen_Shot_2021-09-17_at_9.37.38_AM.png)\n\nWe then grab the transaction with our `getTransactionFromEl` function. Remember, this is going to return the transaction from our intercepted response, which is a fixture.\n\n```js\nconst transaction = getTransactionFromEl($el)\n```\n\nHere is the transaction from the fixture:\n\n```js\n{\n      \"amount\": 8647,\n      \"balanceAtCompletion\": 8958,\n      \"createdAt\": \"2019-12-10T21:38:16.311Z\",\n      \"description\": \"Payment: db4uxOm7d to IMbeyzHTj9\",\n      \"id\": \"si_aNEMbyCA\",\n      \"modifiedAt\": \"2020-05-06T08:15:48.263Z\",\n      \"privacyLevel\": \"private\",\n      \"receiverId\": \"IMbeyzHTj9\",\n      \"requestResolvedAt\": \"2020-06-09T19:01:15.675Z\",\n      \"requestStatus\": \"\",\n      \"senderId\": \"db4uxOm7d\",\n      \"source\": \"GYDJUNEaOK7\",\n      \"status\": \"complete\",\n      \"uuid\": \"41754166-ea5b-448a-9a8a-374ce387c714\",\n      \"receiverName\": \"Kevin\",\n      \"senderName\": \"Amir\",\n      \"likes\": [],\n      \"comments\": []\n    },\n```\n\nWe then use a 3rd part library called [Dinero.js](https://dinerojs.com/) to properly format the amount.\n\n```js\nconst formattedAmount = Dinero({\n  amount: transaction.amount,\n}).toFormat()\n```\n\nThis will convert the `\"amount\": 8647` from the fixture above to **$86.47**\n\n```js\nexpect([TransactionStatus.pending, TransactionStatus.complete]).to.include(\n  transaction.status\n)\n```\n\nThen we write an expectation asserting that our transactions status must be either \"pending\" or \"complete.\" Both of these statuses are coming from a TypeScript enum which can be found in **src/models/transacation.ts** around line **4**.\n\n```js\nexport enum TransactionStatus {\n  pending = \"pending\",\n  incomplete = \"incomplete\",\n  complete = \"complete\",\n}\n```\n\nWe then write another assertion to make sure that the `requestStatus` is empty.\n\n```js\nexpect(transaction.requestStatus).to.be.empty\n```\n\nWe then have a couple assertions to make sure that the UI's likes and comment count are correct.\n\n```js\ncy.getBySelLike(\"like-count\").should(\"have.text\", `${transaction.likes.length}`)\ncy.getBySelLike(\"comment-count\").should(\n  \"have.text\",\n  `${transaction.comments.length}`\n)\n```\n\n![](/images/real-world-examples/transaction-feeds/renders-transactions-item-variations-in-feed/Screen_Shot_2021-09-17_at_9.48.04_AM.png)\n\nNext, we confirm that the sender and receiver of the transaction are the correct persons.\n\n```js\ncy.getBySelLike(\"sender\").should(\"contain\", transaction.senderName)\ncy.getBySelLike(\"receiver\").should(\"contain\", transaction.receiverName)\n```\n\n![](/images/real-world-examples/transaction-feeds/renders-transactions-item-variations-in-feed/Screen_Shot_2021-09-17_at_9.47.50_AM.png)\n\nFinally, we are asserting that the amount displayed in the DOM is correct and has the correct css. In the case of this transaction amount, since it is negative, the UI should display a \"-\" before the dollar amount and make it red.\n\n```js\ncy.getBySelLike(\"amount\")\n  .should(\"contain\", `-${formattedAmount}`)\n  .should(\"have.css\", \"color\", \"rgb(255, 0, 0)\")\n```\n\n![](/images/real-world-examples/transaction-feeds/renders-transactions-item-variations-in-feed/Screen_Shot_2021-09-17_at_9.48.25_AM.png)\n\nNow that you understand how we are testing for \"paid\" transaction items, you can see we are more or less doing the same thing for both \"charged\" and \"requested\" transactions in the rest of the test.\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Renders Transactions Item Variations In Feed"},"url":"/real-world-examples/renders-transactions-item-variations-in-feed","type":"lvl1"},{"title":"Transaction Feeds Overview And Setup","content":"# Transaction Feeds Overview & Setup\n\nIn this section we will be discussing the various tests located within the **cypress/tests/ui/new-transaction-feeds.spec.ts** file.\n\n## ctx & feedViews Objects\n\n```js\nconst ctx: TransactionFeedsCtx = {}\n\nconst feedViews = {\n  public: {\n    tab: \"public-tab\",\n    tabLabel: \"everyone\",\n    routeAlias: \"publicTransactions\",\n    service: \"publicTransactionService\",\n  },\n  contacts: {\n    tab: \"contacts-tab\",\n    tabLabel: \"friends\",\n    routeAlias: \"contactsTransactions\",\n    service: \"contactTransactionService\",\n  },\n  personal: {\n    tab: \"personal-tab\",\n    tabLabel: \"mine\",\n    routeAlias: \"personalTransactions\",\n    service: \"personalTransactionService\",\n  },\n}\n```\n\nThe `ctx` object is an empty object that we will later populate within the `beforeEach()` below with some user data used through the tests in this file.\nThe `feedViews` object contains various information for the different views depending upon which transaction feed we are testing. For example, for the `public` feed views object.\n\n- The `tab` property is the name of the selector we will use to grab the correct element.\n- The `tabLabel` is the text contained within the `<label>` element for the tab.\n- The `routeAlias` is the alias name we are using for <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" />\n- The `service` is the name of the service we are using for a custom Cypress command `cy.nextTransactionFeedPage(feed.service, pageData.totalPages);` around line **203**.\n\n## beforeEach()\n\n```js\nbeforeEach(function () {\n  cy.task(\"db:seed\")\n\n  cy.intercept(\"GET\", \"/notifications\").as(\"notifications\")\n  cy.intercept(\"GET\", \"/transactions*\").as(feedViews.personal.routeAlias)\n  cy.intercept(\"GET\", \"/transactions/public*\").as(feedViews.public.routeAlias)\n  cy.intercept(\"GET\", \"/transactions/contacts*\").as(\n    feedViews.contacts.routeAlias\n  )\n\n  cy.database(\"filter\", \"users\").then((users: User[]) => {\n    ctx.user = users[0]\n    ctx.allUsers = users\n\n    cy.loginByXstate(ctx.user.username)\n  })\n})\n```\n\nFirst, we are using a custom Cypress task to seed our database.\n\n```js\ncy.task(\"db:seed\")\n```\n\nNext, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept various requests and alias them using the data within the `feedViews` object.\n\n```js\ncy.intercept(\"GET\", \"/notifications\").as(\"notifications\")\ncy.intercept(\"GET\", \"/transactions*\").as(feedViews.personal.routeAlias)\ncy.intercept(\"GET\", \"/transactions/public*\").as(feedViews.public.routeAlias)\ncy.intercept(\"GET\", \"/transactions/contacts*\").as(feedViews.contacts.routeAlias)\n```\n\nThen, we use a custom Cypress command `cy.database()` to retrieve some users from the database. We then use the users returned from the database and add them to our `ctx` object later in our tests.\nFinally, we are using another custom Cypress command `cy.loginByXstate()` to login as one of the users returned from the database.\n\n```js\ncy.database(\"filter\", \"users\").then((users: User[]) => {\n  ctx.user = users[0]\n  ctx.allUsers = users\n\n  cy.loginByXstate(ctx.user.username)\n})\n```\n\n![](/images/real-world-examples/transaction-feeds/transaction-feeds-overview-and-setup/Screen_Shot_2021-09-16_at_9.33.23_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Transaction Feeds Overview And Setup"},"url":"/real-world-examples/transaction-feeds-overview-and-setup","type":"lvl1"},{"title":"Comments On A Transaction","content":"# comments on a transaction\n\nBefore continuing, make sure you have read the [Transaction View Overview & Setup](/real-world-examples/transaction-view-overview-and-setup) lesson first.\n\n```js\nit(\"comments on a transaction\", function () {\n  cy.getBySelLike(\"transaction-item\").first().click()\n  cy.wait(\"@getTransaction\")\n\n  const comments = [\"Thank you!\", \"Appreciate it.\"]\n\n  comments.forEach((comment, index) => {\n    cy.getBySelLike(\"comment-input\").type(`${comment}{enter}`)\n    cy.getBySelLike(\"comments-list\").children().eq(index).contains(comment)\n  })\n\n  cy.getBySelLike(\"comments-list\")\n    .children()\n    .should(\"have.length\", comments.length)\n  cy.visualSnapshot(\"Comment on Transaction\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we click on the first transaction and wait upon the `@getTransaction` intercept.\n\n```js\ncy.getBySelLike(\"transaction-item\").first().click()\ncy.wait(\"@getTransaction\")\n```\n\n![](/images/real-world-examples/transaction-view/comments-on-a-transaction/Screen_Shot_2021-09-16_at_9.19.47_AM.png)\n\nNext, we loop through the array of comments, typing in each one and ensuring the comment is displayed in the UI.\n\n```js\nconst comments = [\"Thank you!\", \"Appreciate it.\"]\n\ncomments.forEach((comment, index) => {\n  cy.getBySelLike(\"comment-input\").type(`${comment}{enter}`)\n  cy.getBySelLike(\"comments-list\").children().eq(index).contains(comment)\n})\n```\n\n![](/images/real-world-examples/transaction-view/comments-on-a-transaction/Screen_Shot_2021-09-16_at_9.20.21_AM.png)\n\nFinally, we confirm that all of our comments in the `comments` array are displayed within the UI.\n\n```js\ncy.getBySelLike(\"comments-list\")\n  .children()\n  .should(\"have.length\", comments.length)\n```\n\n![](/images/real-world-examples/transaction-view/comments-on-a-transaction/Screen_Shot_2021-09-16_at_9.21.02_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Comments On A Transaction"},"url":"/real-world-examples/comments-on-a-transaction","type":"lvl1"},{"title":"Does Not Display Accept Reject Buttons On Completed Request","content":"# does not display accept reject buttons on completed request\n\nBefore continuing, make sure you have read the [Transaction View Overview & Setup](/real-world-examples/transaction-view-overview-and-setup) lesson first.\n\n```js\nit(\"does not display accept/reject buttons on completed request\", function () {\n    cy.database(\"find\", \"transactions\", {\n      receiverId: ctx.authenticatedUser!.id,\n      status: \"complete\",\n      requestStatus: \"accepted\",\n    }).then((transactionRequest) => {\n      cy.visit(`/transaction/${transactionRequest!.id}`);\n\n      cy.wait(\"@getNotifications\");\n      cy.getBySel(\"nav-top-notifications-count\").should(\"be.visible\");\n      cy.getBySel(\"transaction-detail-header\").should(\"be.visible\");\n      cy.getBySel(\"transaction-accept-request\").should(\"not.exist\");\n      cy.getBySel(\"transaction-reject-request\").should(\"not.exist\");\n      cy.getBySel(\"transaction-detail-header\").should(\"be.visible\");\n      cy.visualSnapshot(\"Transaction Completed (not able to accept or reject)\");\n    });\n  });\n\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nThe first thing we do is retrieve a \"complete\" transaction from the database associated with our `authenticatedUser`, which we set up in the `beforeEach()` hook at the top of this spec file. This test is another example of a \"Data-Driven Test.\" Rather than hard-coding this information, we are using real data from our database to drive our test.\n\n```js\ncy.database(\"find\", \"transactions\", {\n      receiverId: ctx.authenticatedUser!.id,\n      status: \"complete\",\n      requestStatus: \"accepted\",\n    }).then((transactionRequest) => {\n// ...\n\n```\n\n![](/images/real-world-examples/transaction-view/does-not-display-accept-reject-buttons-on-completed-request/Screen_Shot_2021-09-16_at_9.22.00_AM.png)\n\nOnce we locate the transaction, we then navigate the application to the specific transactions screen.\n\n```js\ncy.visit(`/transaction/${transactionRequest!.id}`);\n\n```\n\nNext, we wait for the `@getNotifications` intercept.\n\n```js\ncy.wait(\"@getNotifications\")\n```\n\n[]()\n\nFinally, we confirm that certain elements are visible or not visible.\n\n```js\ncy.getBySel(\"nav-top-notifications-count\").should(\"be.visible\")\ncy.getBySel(\"transaction-detail-header\").should(\"be.visible\")\ncy.getBySel(\"transaction-accept-request\").should(\"not.exist\")\ncy.getBySel(\"transaction-reject-request\").should(\"not.exist\")\ncy.getBySel(\"transaction-detail-header\").should(\"be.visible\")\n```\n\n![](/images/real-world-examples/transaction-view/does-not-display-accept-reject-buttons-on-completed-request/Screen_Shot_2021-09-16_at_9.22.50_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Does Not Display Accept Reject Buttons On Completed Request"},"url":"/real-world-examples/does-not-display-accept-reject-buttons-on-completed-request","type":"lvl1"},{"title":"Rejects A Transaction Request","content":"# rejects a transaction request\n\nBefore continuing, make sure you have read the [Transaction View Overview & Setup](/real-world-examples/transaction-view-overview-and-setup) lesson first.\n\n```js\nit(\"rejects a transaction request\", function () {\n    cy.visit(`/transaction/${ctx.transactionRequest!.id}`);\n    cy.wait(\"@getTransaction\");\n\n    cy.getBySelLike(\"reject-request\").click();\n    cy.wait(\"@updateTransaction\").its(\"response.statusCode\").should(\"equal\", 204);\n    cy.getBySelLike(\"reject-request\").should(\"not.exist\");\n    cy.getBySel(\"transaction-detail-header\").should(\"be.visible\");\n    cy.visualSnapshot(\"Transaction Rejected\");\n  });\n\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we visit the transaction screen for the specific transaction we looked up within the `beforeEach()` hook at the top of the spec file. Then we wait upon the `@getTransaction` intercept.\n\n```js\ncy.visit(`/transaction/${ctx.transactionRequest!.id}`);\n    cy.wait(\"@getTransaction\");\n\n```\n\nNext, we click on the \"Reject Request\" button and wait on the `@updateTransaction` intercept and confirm that this intercepts status code is **204**.\n\n```js\ncy.getBySelLike(\"reject-request\").click()\ncy.wait(\"@updateTransaction\").its(\"response.statusCode\").should(\"equal\", 204)\n```\n\n![](/images/real-world-examples/transaction-view/rejects-a-transaction-request/Screen_Shot_2021-09-16_at_9.24.53_AM.png)\n\n![](/images/real-world-examples/transaction-view/rejects-a-transaction-request/Screen_Shot_2021-09-16_at_9.25.17_AM.png)\n\nFinally, we make sure the reject request button is no longer in the DOM and that the transaction detail header is visible.\n\n```js\ncy.getBySelLike(\"reject-request\").should(\"not.exist\")\ncy.getBySel(\"transaction-detail-header\").should(\"be.visible\")\n```\n\n![](/images/real-world-examples/transaction-view/rejects-a-transaction-request/Screen_Shot_2021-09-16_at_9.25.33_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Rejects A Transaction Request"},"url":"/real-world-examples/rejects-a-transaction-request","type":"lvl1"},{"title":"Transaction View Overview And Setup","content":"# Transaction View Overview & Setup\n\nIn this section, we will be discussing the various tests located within the **cypress/tests/ui/new-transaction-view.spec.ts** file.\n\nLet's break down what is happening within the `beforeEach()` as it is important to understand what is going on since this hook is running before each test.\n\n## beforeEach()\n\n```js\nconst ctx: NewTransactionCtx = {}\n\nbeforeEach(function () {\n  cy.task(\"db:seed\")\n\n  cy.intercept(\"GET\", \"/transactions*\").as(\"personalTransactions\")\n  cy.intercept(\"GET\", \"/transactions/public*\").as(\"publicTransactions\")\n  cy.intercept(\"GET\", \"/transactions/*\").as(\"getTransaction\")\n  cy.intercept(\"PATCH\", \"/transactions/*\").as(\"updateTransaction\")\n\n  cy.intercept(\"GET\", \"/checkAuth\").as(\"userProfile\")\n  cy.intercept(\"GET\", \"/notifications\").as(\"getNotifications\")\n  cy.intercept(\"GET\", \"/bankAccounts\").as(\"getBankAccounts\")\n\n  cy.database(\"find\", \"users\").then((user: User) => {\n    ctx.authenticatedUser = user\n\n    cy.loginByXstate(ctx.authenticatedUser.username)\n\n    cy.database(\"find\", \"transactions\", {\n      receiverId: ctx.authenticatedUser.id,\n      status: \"pending\",\n      requestStatus: \"pending\",\n      requestResolvedAt: \"\",\n    }).then((transaction: Transaction) => {\n      ctx.transactionRequest = transaction\n    })\n  })\n\n  cy.getBySel(\"nav-personal-tab\").click()\n  cy.wait(\"@personalTransactions\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used [here](/real-world-examples/custom-cypress-commands).\n\nThe `ctx` object is an empty object that we will later populate within the `beforeEach()` with some user data used through the tests in this file.\n\nFirst, we are using a custom Cypress task to seed our database.\n\n```js\ncy.task(\"db:seed\")\n```\n\nNext, we use <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept various requests and aliasing them.\n\n```js\ncy.intercept(\"GET\", \"/transactions*\").as(\"personalTransactions\")\ncy.intercept(\"GET\", \"/transactions/public*\").as(\"publicTransactions\")\ncy.intercept(\"GET\", \"/transactions/*\").as(\"getTransaction\")\ncy.intercept(\"PATCH\", \"/transactions/*\").as(\"updateTransaction\")\n\ncy.intercept(\"GET\", \"/checkAuth\").as(\"userProfile\")\ncy.intercept(\"GET\", \"/notifications\").as(\"getNotifications\")\ncy.intercept(\"GET\", \"/bankAccounts\").as(\"getBankAccounts\")\n```\n\nThen, we use a custom Cypress command `cy.database()` to retrieve the users from our database. We then add this user to our `ctx` object and log in with `cy.loginByXstate()`.\nWe then perform another query to our database using `cy.databse()` to find all of the \"pending\" transactions for our user and store said pending transaction on the `ctx` object.\n\n```js\ncy.database(\"find\", \"users\").then((user: User) => {\n  ctx.authenticatedUser = user\n\n  cy.loginByXstate(ctx.authenticatedUser.username)\n\n  cy.database(\"find\", \"transactions\", {\n    receiverId: ctx.authenticatedUser.id,\n    status: \"pending\",\n    requestStatus: \"pending\",\n    requestResolvedAt: \"\",\n  }).then((transaction: Transaction) => {\n    ctx.transactionRequest = transaction\n  })\n})\n```\n\n![](/images/real-world-examples/transaction-view/transaction-view-overview-and-setup/Screen_Shot_2021-09-16_at_9.18.09_AM.png)\n\n![](/images/real-world-examples/transaction-view/transaction-view-overview-and-setup/Screen_Shot_2021-09-16_at_9.18.44_AM.png)\n\nFinally, we click on the personal transaction tab and wait on the `@personalTransactions` intercept.\n\n```js\ncy.getBySel(\"nav-personal-tab\").click()\ncy.wait(\"@personalTransactions\")\n```\n\n![](/images/real-world-examples/transaction-view/transaction-view-overview-and-setup/Screen_Shot_2021-09-16_at_9.19.05_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Transaction View Overview And Setup"},"url":"/real-world-examples/transaction-view-overview-and-setup","type":"lvl1"},{"title":"Transactions Navigation Tabs Are Hidden On A Transaction View Page","content":"# transactions navigation tabs are hidden on a transaction view page\n\nBefore continuing, make sure you have read the [Transaction View Overview & Setup](/real-world-examples/transaction-view-overview-and-setup) lesson first.\n\n```js\nit(\"transactions navigation tabs are hidden on a transaction view page\", function () {\n  cy.getBySelLike(\"transaction-item\").first().click()\n  cy.location(\"pathname\").should(\"include\", \"/transaction\")\n  cy.getBySel(\"nav-transaction-tabs\").should(\"not.exist\")\n  cy.getBySel(\"transaction-detail-header\").should(\"be.visible\")\n  cy.visualSnapshot(\"Transaction Navigation Tabs Hidden\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nThis is a relatively straightforward test in which we are making sure that the transaction navigation tabs are hidden on the transaction view page.\n\nThe first thing we do is click on the first transaction and confirm that the application routes us to that transactions page.\n\n```js\ncy.getBySelLike(\"transaction-item\").first().click()\ncy.location(\"pathname\").should(\"include\", \"/transaction\")\n```\n\n![](/images/real-world-examples/transaction-view/transactions-navigation-tabs-are-hidden-on-a-transaction-view-page/Screen_Shot_2021-09-16_at_9.26.18_AM.png)\n\nFinally, we confirm that the transaction tabs are not in the DOM and that the transaction header is visible.\n\n```js\ncy.getBySel(\"nav-transaction-tabs\").should(\"not.exist\")\ncy.getBySel(\"transaction-detail-header\").should(\"be.visible\")\n```\n\n![](/images/real-world-examples/transaction-view/transactions-navigation-tabs-are-hidden-on-a-transaction-view-page/Screen_Shot_2021-09-16_at_9.26.40_AM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Transactions Navigation Tabs Are Hidden On A Transaction View Page"},"url":"/real-world-examples/transactions-navigation-tabs-are-hidden-on-a-transaction-view-page","type":"lvl1"},{"title":"Updating User Settings","content":"# Updating User Settings\n\nBefore continuing, make sure you have read the [User Settings Overview & Setup](/real-world-examples/user-settings-overview-and-setup) lesson first.\n\n```js\nit(\"updates first name, last name, email and phone number\", function () {\n  cy.getBySelLike(\"firstName\").clear().type(\"New First Name\")\n  cy.getBySelLike(\"lastName\").clear().type(\"New Last Name\")\n  cy.getBySelLike(\"email\").clear().type(\"email@email.com\")\n  cy.getBySelLike(\"phoneNumber-input\").clear().type(\"6155551212\").blur()\n\n  cy.getBySelLike(\"submit\").should(\"not.be.disabled\")\n  cy.getBySelLike(\"submit\").click()\n\n  cy.wait(\"@updateUser\").its(\"response.statusCode\").should(\"equal\", 204)\n\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click()\n  }\n\n  cy.getBySel(\"sidenav-user-full-name\").should(\"contain\", \"New First Name\")\n  cy.visualSnapshot(\"User Settings Update Profile\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\nFirst, we need to grab all of the input fields and fill them with the data we want to update.\n\n```js\ncy.getBySelLike(\"firstName\").clear().type(\"New First Name\")\ncy.getBySelLike(\"lastName\").clear().type(\"New Last Name\")\ncy.getBySelLike(\"email\").clear().type(\"email@email.com\")\ncy.getBySelLike(\"phoneNumber-input\").clear().type(\"6155551212\").blur()\n```\n\nWe then assert that the submit is not disabled and then <apiLink apiName=\"click\" displayName=\".click()\" /> on it.\n\n```js\ncy.getBySelLike(\"submit\").should(\"not.be.disabled\")\ncy.getBySelLike(\"submit\").click()\n```\n\nNext, we make an assertion that our intercept which is aliased to `@updateUser` returns the correct status code. Remember this intercept happens inside the `beforeEach()` hook before every test is run.\n\n```js\ncy.wait(\"@updateUser\").its(\"response.statusCode\").should(\"equal\", 204)\n```\n\nThen we use our custom `isMobile()` utility function to determine if this is a mobile device or not. If so, we click on the button to toggle the sidebar.\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\n```\n\nFinally, we make an assertion that our new name entered has been updated succesfully.\n\n```js\ncy.getBySel(\"sidenav-user-full-name\").should(\"contain\", \"New First Name\")\n```\n\n![](/images/real-world-examples/user-settings/updating-user-settings/Screen_Shot_2021-06-29_at_3.12.06_PM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"Updating User Settings"},"url":"/real-world-examples/updating-user-settings","type":"lvl1"},{"title":"User Setting Form Errors","content":"# User Setting Form Errors\n\nBefore continuing, make sure you have read the [User Settings Overview & Setup](/real-world-examples/user-settings-overview-and-setup) lesson first.\n\n```js\nit(\"should display user setting form errors\", function () {\n  ;[\"first\", \"last\"].forEach((field) => {\n    cy.getBySelLike(`${field}Name-input`).type(\"Abc\").clear().blur()\n    cy.get(`#user-settings-${field}Name-input-helper-text`)\n      .should(\"be.visible\")\n      .and(\"contain\", `Enter a ${field} name`)\n  })\n\n  cy.getBySelLike(\"email-input\").type(\"abc\").clear().blur()\n  cy.get(\"#user-settings-email-input-helper-text\")\n    .should(\"be.visible\")\n    .and(\"contain\", \"Enter an email address\")\n\n  cy.getBySelLike(\"email-input\").type(\"abc@bob.\").blur()\n  cy.get(\"#user-settings-email-input-helper-text\")\n    .should(\"be.visible\")\n    .and(\"contain\", \"Must contain a valid email address\")\n\n  cy.getBySelLike(\"phoneNumber-input\").type(\"abc\").clear().blur()\n  cy.get(\"#user-settings-phoneNumber-input-helper-text\")\n    .should(\"be.visible\")\n    .and(\"contain\", \"Enter a phone number\")\n\n  cy.getBySelLike(\"phoneNumber-input\").type(\"615-555-\").blur()\n  cy.get(\"#user-settings-phoneNumber-input-helper-text\")\n    .should(\"be.visible\")\n    .and(\"contain\", \"Phone number is not valid\")\n\n  cy.getBySelLike(\"submit\").should(\"be.disabled\")\n  cy.visualSnapshot(\"User Settings Form Errors and Submit Disabled\")\n})\n```\n\nYou can find out more information about the custom Cypress commands used in this test [here](/real-world-examples/custom-cypress-commands).\n\n## First & Last Name Inputs\n\nFirst, we are looping through an array of two strings to find the firstName and lastName inputs. Remember, [Cypress is just JavaScript](http://localhost:3000/cypress-fundamentals/cypress-is-just-javascript), so we can use `Array.forEach()` to simplify our code and remove duplication.\n\n```js\n;[\"first\", \"last\"].forEach((field) => {\n  cy.getBySelLike(`${field}Name-input`).type(\"Abc\").clear().blur()\n  cy.get(`#user-settings-${field}Name-input-helper-text`)\n    .should(\"be.visible\")\n    .and(\"contain\", `Enter a ${field} name`)\n})\n```\n\nWe then instruct Cypress to use <apiLink apiName=\"type\" displayName=\".type()\" /> to enter \"Abc\" into each input, clear the input, and trigger the blur event on the input. We then assert that the validation error is triggered and contains the correct error message.\n\n![](/images/real-world-examples/user-settings/user-setting-form-errors/Screen_Shot_2021-06-29_at_1.29.56_PM.png)\n\n## Email & Phone inputs\n\nLet's finish our test by asserting that the email and phone inputs are also throwing the correct error messages. The code is virtually identical to the last name and first name code above. The only difference is the selector name.\n\n```js\ncy.getBySelLike(\"email-input\").type(\"abc\").clear().blur()\ncy.get(\"#user-settings-email-input-helper-text\")\n  .should(\"be.visible\")\n  .and(\"contain\", \"Enter an email address\")\n\ncy.getBySelLike(\"email-input\").type(\"abc@bob.\").blur()\ncy.get(\"#user-settings-email-input-helper-text\")\n  .should(\"be.visible\")\n  .and(\"contain\", \"Must contain a valid email address\")\n\ncy.getBySelLike(\"phoneNumber-input\").type(\"abc\").clear().blur()\ncy.get(\"#user-settings-phoneNumber-input-helper-text\")\n  .should(\"be.visible\")\n  .and(\"contain\", \"Enter a phone number\")\n\ncy.getBySelLike(\"phoneNumber-input\").type(\"615-555-\").blur()\ncy.get(\"#user-settings-phoneNumber-input-helper-text\")\n  .should(\"be.visible\")\n  .and(\"contain\", \"Phone number is not valid\")\n```\n\nWe have two different assertions for both the email and phone number fields since these two fields can show different error messages depending upon the error.\n\nFinally, we will make sure that the submit button is disabled since there are errors with our form.\n\n```js\ncy.getBySelLike(\"submit\").should(\"be.disabled\")\n```\n\n![](/images/real-world-examples/user-settings/user-setting-form-errors/Screen_Shot_2021-06-29_at_1.37.46_PM.png)\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"User Setting Form Errors"},"url":"/real-world-examples/user-setting-form-errors","type":"lvl1"},{"title":"User Settings Overview And Setup","content":"# User Settings Overview & Setup\n\n![](/images/real-world-examples/user-settings/user-settings-overview-and-setup/Screen_Shot_2021-06-29_at_9.51.44_AM.png)\n\nIn this section, we will be discussing the various tests located within the **cypress/tests/ui/user-settings.spec.ts** file.\n\nLet's breakdown what is happening within the `beforeEach()` as it is important to understand what is going on since this hook is running before each test.\n\n## beforeEach()\n\n```js\nbeforeEach(function () {\n  cy.task(\"db:seed\")\n\n  cy.intercept(\"PATCH\", \"/users/*\").as(\"updateUser\")\n  cy.intercept(\"GET\", \"/notifications*\").as(\"getNotifications\")\n\n  cy.database(\"find\", \"users\").then((user: User) => {\n    cy.loginByXstate(user.username)\n  })\n\n  if (isMobile()) {\n    cy.getBySel(\"sidenav-toggle\").click()\n  }\n\n  cy.getBySel(\"sidenav-user-settings\").click()\n})\n```\n\nYou can find out more information about the custom Cypress commands used [here](/real-world-examples/custom-cypress-commands).\n\nThe first thing we are doing is seeding our database using a custom Cypress task.\n\n```js\ncy.task(\"db:seed\")\n```\n\nNext, we are using <apiLink apiName=\"intercept\" displayName=\"cy.intercept()\" /> to intercept every **PATCH** request to the **/users/\\*** route. We are then aliasing this intercept to \"updateUser.\" When you see `@updateUser` being used within a test, it is referring to this intercept.\n\n```js\ncy.intercept(\"PATCH\", \"/users/*\").as(\"updateUser\")\n```\n\nWe are also intercepting any **GET** request to the **/notifications** route and aliasing the intercept to \"getNotifications.\" When you see `@getNotifications` being used within a test, it is referring to this intercept.\n\n```js\ncy.intercept(\"GET\", \"/notifications*\").as(\"getNotifications\")\n```\n\nWe then use a custom Cypress command `cy.database()` to query our database for our users. Then we use another custom Cypress command `cy.loginByXstate()` to login into the application using one of the users returned from `cy.database()`.\n\nYou can find out how these custom Commands work in greater detail [here](/real-world-examples/custom-cypress-commands).\n\n```js\ncy.database(\"find\", \"users\").then((user: User) => {\n  cy.loginByXstate(user.username)\n})\n```\n\nFinally, we click the button to open the user settings window. We have a special utility function to determine if we are simulating a mobile device or not. You can find out how the `isMobile()` function works in greater detail [here](/real-world-examples/custom-cypress-commands).\n\n```js\nif (isMobile()) {\n  cy.getBySel(\"sidenav-toggle\").click()\n}\n\ncy.getBySel(\"sidenav-user-settings\").click()\n```\n","hierarchy":{"lvl0":{"defaultValue":"Lessons"},"lvl1":"User Settings Overview And Setup"},"url":"/real-world-examples/user-settings-overview-and-setup","type":"lvl1"}]